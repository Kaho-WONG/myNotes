# 算法解析

![1634621192597](C:\Users\王嘉豪\AppData\Roaming\Typora\typora-user-images\1634621192597.png)



# 排序算法

 ![img](https://upload-images.jianshu.io/upload_images/12585785-0d5c1ef679da90f6.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp) 

## 冒泡排序

**算法思想：**

1.比较相邻的元素。如果第一个比第二个大，就交换他们两个。  

2.对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。

3.针对所有的元素重复以上的步骤，除了最后一个。

4.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

**平均时间复杂度： O(n²)**

**算法稳定性：**相邻换位，**稳定**

**图示：**

 <img src="./imgs/1.gif" alt="img"  /> 

```java
public void bubbleSort(int[] a){
    //升序
    for (int i = 0;i < a.length - 1;i++){
        for (int j = 0;j < a.length - 1 - i;j++){
            if (a[j] > a[j + 1]){
                //交换元素位置（相邻换位）
                int temp = a[j];
                a[j] = a[j + 1];
                a[j + 1] = temp;
            }
        }
    }
}
```



## 选择排序

**算法思想：**首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它和数组的第二个元素交换位置。如此往复，直到将整个数组排序。

**平均时间复杂度： O(n²)**

**算法稳定性：**跨步换位，**不稳定**

**图示：**

![img](./imgs/2.gif) 

```java
public void selectSort( int[] a){
	//升序
	for (int i = 0;i < a.length;i++){
    	int min = i;//交换下标可以减少元素移动次数
    	for (int j = i + 1;j < a.length;j++){
         	//比较得出最小的元素并取其下标为最小元素的下标
         	if (a[j] < a[min]){
             	min = j;
          	}
      	}
        //交换元素位置,跨步换位
        int temp = a[i];
        a[i] = a[min];
        a[min] = temp;
   	}
}
```



## 插入排序

**算法思想：**插入排序是指在待排序的元素中，假设前面n-1(其中n>=2)个数已经是排好顺序的，现将第n个数插到前面已经排好的序列中，然后找到合适自己的位置，使得插入第n个数的这个序列也是排好顺序的。按照此法对所有元素进行插入，直到整个序列排为有序的过程。

**平均时间复杂度： O(n²)**

**算法稳定性：**相邻换位，**稳定**

**图示：**

<img src="./imgs/3.gif" alt="img"  /> 

```java
//简单的插入排序，每比出一个大于现排元素的元素就将它们两个换位
public void insertSort(int[] a){
	//升序
    for (int i = 1;i < a.length;i++){
        //默认第一个元素已被排序好了
        for (int j = i;j > 0;j--) {
            if (a[j] < a[j - 1]) {
                int temp = a[j];
                a[j] = a[j - 1];
                a[j - 1] = temp;
            }
        }
    }
}

//优化后的插入排序算法:相比上面的方法元素替换次数更少
//a表示数组，n表示数组大小
public void insertSort_1(int[] a,int n){
    if (n <= 1) return;//若数组大小≤1，直接返回
    for (int i = 1; i < n; ++i) {
        int value = a[i];
        int j = i - 1;
        // 查找插入的位置
        for (; j >= 0; --j) {
            if (a[j] > value) {
                a[j+1] = a[j]; //若往前迭代过程中不断有元素大于a[i]，则将每个大于a[i]的元素后移一位
            } else {
                break; //出现了小于a[i]的元素，则此趟内循环已找到a[i]需要插入的位置，无需继续往前比较
            }
        }
        a[j+1] = value; // 插入数据
    }
}
```



## 希尔排序

> 直接插入排序的改进版，更为高效。

**算法思想：**先将要排序的一组数按某个增量d分成若干组，每组中记录的下标相差d。对每组中全部元素进行排序，然后再用一个较小的增量对它进行分组，在每组中再进行排序。当增量减到1时，整个要排序的数被分成一组，排序完成。一般的初次取序列的一半为增量，以后每次减半，直到增量为1。

**平均时间复杂度：O(nlogn)**

**算法稳定性：**跳跃性插入，**不稳定**

**图示：**

示例一：

 ![img](./imgs/4.png)

示例二：

 <img src="./imgs/5.gif" alt="img" style="zoom:67%;" />  

```java
public void shellSort(int[] arr){
    
	if(arr == null || arr.length <= 1){
        return;
    }
    int N = arr.length;//数组长度
    int inserted;//用来记录正在被插入的 arr[i] 元素
    int j;
	
    //进行分组，最开始时的增量(gap)为数组长度的一半，往后每次减半
    for (int gap = N/2;gap > 0;gap /= 2){
        //分别对各个分组进行插入排序
        /*
        注意:对各个组进行插入的时候并不是对一个组进行排序完再对另一个组进行排序，
            而是轮流对每个组进行插入排序
         */
        for (int i = gap;i < N;i++){
            //i:代表即将插入的元素角标，作为每一组比较数据的最后一个元素角标 
            //j:代表与i同一组的数组元素角标
            //将 arr[i]插入到其所在分组的正确位置上去(从后往前比较并插入)
            inserted = arr[i];//记录正在被插入的元素
            //插入的时候按组进行插入排序(组内元素两两间隔gap)
            for (j = i - gap;j >= 0 && inserted < arr[j];j -= gap){
                //(循环)若同组内的前一个元素大于正在被插入的元素，则将前一个元素(后移)赋给后一个元素
                arr[j + gap] = arr[j];
            }
            //前面已经没有比arr[i]小的元素，则将arr[i]插入到正确的位置上
            arr[j + gap] = inserted;
        }
    }
}
```



## 归并排序

**算法思想：**归并排序是用**分治**思想，分治模式在每一层递归上有三个步骤：

- **分解（Divide）**：将n个元素分成个含n/2个元素的子序列。
- **解决（Conquer）**：用合并排序法对两个子序列递归的排序。
- **合并（Combine）**：合并两个已排序的子序列已得到排序结果。

**平均时间复杂度：O(nlogn)**

**算法稳定性：稳定**

**图示：**

<img src="./imgs/6.gif" alt="img" style="zoom:67%;" /> 

```java
/**
 * 将数组 arr[left] ----> arr[right] 进行自顶向下的归并排序
 * @param arr 要排序的数组
 * @param temp 辅助数组，和arr同样大的空数组，作为临时存放的空间
 * @param left 左边界
 * @param right 右边界
 */
public void mergeSort(int[] arr,int[] temp,int left,int right){
    //left==right时，就递归到只有一个元素 ---> 终止条件
    if (left < right){
        //[分]:将数组一分为二
        int mid = left + (right - left) / 2;
        //递归调用，不断将子数组一分为二，分到最后只有一个元素，就不治而治了(只有一个元素认为它有序)
        //[治]:将左边数组排序 arr[left] ---> arr[mid]
        mergeSort(arr,temp,left,mid);
        //[治]:将右边数组排序 arr[mid + 1] ---> arr[right]
        mergeSort(arr,temp,mid + 1,right);
        //[合]:合并两个有序数组【原地归并】
        merge(arr,temp,left,mid,right);
    }
}

//将 arr[left...mid] 和 arr[mid+1...right] 两个有序数组合并为一个有序数组
private static void merge(int[] arr,int[] temp,int left,int mid,int right){
    int i = left,j = mid + 1;//i用于标记左边数组下标，j用于标记右边数组下标
    //先通过比较将两个有序数组合并为一个有序数组，结果暂放到 temp 数组
    for (int k = left;k <= right;k++){
        //如果左边数组arr[left...mid]中的元素取完[即比较完](i > mid)
        //则直接copy右边数组的元素到辅助数组，右边数组同理
        if (i > mid)                temp[k] = arr[j++];//左边数组全存放完了
        else if (j > right)         temp[k] = arr[i++];//右边数组全存放完了
        else if (arr[i] < arr[j])   temp[k] = arr[i++];
        else                        temp[k] = arr[j++];//arr[i] > arr[j]
    }

    //再将已经排序好的辅助数组中的值复制到原数组 arr 中去
    for (int k = left;k <= right;k++){
        arr[k] = temp[k];
    }
}
```



## 快速排序

**算法思想：** 快速排序基于**分治**的思想。

在待排序的数列中，首先找一个数字作为基准数。为了方便，一般选择第 1 个数字作为基准数。接下来把这个待排序的数列中小于基准数的元素移动到待排序的数列的左边，把大于基准数的元素移动到待排序的数列的右边。这时，左右两个分区的元素就相对有序了；接着把两个分区的元素分别按照上面两种方法继续对每个分区找出基准数，然后移动，直到各个分区只有一个数时为止。 

**平均时间复杂度：O(nlogn)**

**算法稳定性：**不稳定

**图示：**这里是将最后一个元素作为主元，下面代码将第一个元素作为主元

 <img src="./imgs/7.gif" alt="img" style="zoom:50%;" /> 

```java
/**
 *快速排序
 * @param a 传入的(子)数组
 * @param left (子)数组左边界
 * @param right 右边界
 */
public void quickSort(int[] a,int left,int right){

    int center; //用来记录每次递归切分数组时数组的中间位置

    if (left < right){
        center = partion(a,left,right); //将(子)数组进行排序的方法
        quickSort(a,left,center - 1); //左半部分
        quickSort(a,center + 1,right); //右半部分
    }
}

/**
 * 私有方法，只供quickSort调用
 * @param a 传入的(子)数组
 * @param left (子)数组的左边界
 * @param right 右边界
 * @return
 */
private int partion(int[] a,int left,int right){

    int pivot = a[left]; //用来存放主元,默认主元为(子)数组左边第一个元素
    int i = left + 1;
    int j = right;
    while (true){
        //向左遍历扫描
        while (i <= j && a[i] <= pivot) i++;
        //向右遍历扫描
        while (i <= j && a[j] >= pivot) j--;
        //当扫描完发现数组有序，则直接退出
        if (i >= j)
            break;

        //交换元素
        int temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
    //将主元与a[j]交换
    a[left] = a[j];
    a[j] = pivot;
    return j; //返回这趟排序完后已定下的中间元素的位置
}
```



## 堆排序

**算法思想：** 将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。

**平均时间复杂度：O(nlogn)**

**算法稳定性：不稳定**

**图示：**

![img](./imgs/8.gif) 

```java
public void heapSort(int[] arr) {
    if (arr == null || arr.length == 0) {
        return; //若数组为空则直接返回
    }
    int len = arr.length;//堆大小，这里数组的第一个位置arr[0]也用来使用了
    // 构建大顶堆，这里其实就是把待排序序列，变成一个大顶堆结构的数组
    buildMaxHeap(arr, len);

    // 交换堆顶和当前堆末尾的节点，重置大顶堆
    for (int i = len - 1; i > 0; i--) {
        swap(arr, 0, i);
        len--;
        heapify(arr, 0, len);//调整大顶堆姿态
    }
}

/**
 * 构建大顶堆
 * @param arr 待排序的数组
 * @param len 数组大小，堆中元素数量为 len-1
 */
private void buildMaxHeap(int[] arr, int len) {
    // 从最后一个非叶子节点开始向前遍历，调整节点性质，使之成为大顶堆
    for (int i = (int)Math.floor(len / 2) - 1; i >= 0; i--) {
        heapify(arr, i, len);
    }
}

/**
 * 从下(最后一个非叶子节点)至上使用sink下沉调整堆姿态
 * @param arr
 * @param i
 * @param len
 */
private void heapify(int[] arr, int i, int len) {
    // 先根据堆性质，找出它左右节点的索引
    int left = 2 * i + 1;
    int right = 2 * i + 2;
    // 默认当前节点（父节点）是最大值。
    int largestIndex = i;
    if (left < len && arr[left] > arr[largestIndex]) {
        // 如果有左节点，并且左节点的值更大，更新最大值的索引
        largestIndex = left;
    }
    if (right < len && arr[right] > arr[largestIndex]) {
        // 如果有右节点，并且右节点的值更大，更新最大值的索引
        largestIndex = right;
    }

    if (largestIndex != i) {
        // 如果最大值不是当前非叶子节点的值，那么就把当前节点和最大值的子节点值互换
        swap(arr, i, largestIndex);
        // 因为互换之后，子节点的值变了，如果该子节点也有自己的子节点，仍需要再次调整。
        heapify(arr, largestIndex, len);//递归
    }
}

/**
 * 交换二叉堆中两个元素位置
 * @param arr
 * @param i
 * @param j
 */
private static void swap (int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```



## 桶排序

**算法思想：** 假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序。

**空间换时间**

**平均时间复杂度：O(n+k)** ，n 为排序元素个数，k 为桶个数

**算法稳定性：稳定**

**图示：**

 ![img](./imgs/9.gif) 

```java
public static void sort(int[] arr){
    //最大最小值
    int max = arr[0];
    int min = arr[0];
    int length = arr.length;

    for(int i=1; i<length; i++) {
        if(arr[i] > max) {
            max = arr[i];
        } else if(arr[i] < min) {
            min = arr[i];
        }
    }

    //最大值和最小值的差
    int diff = max - min;

    //桶列表
    ArrayList<ArrayList<Integer>> bucketList = new ArrayList<>();
    for(int i = 0; i < length; i++){
        bucketList.add(new ArrayList<>());
    }

    //每个桶的存数区间
    float section = (float) diff / (float) (length - 1);

    //数据入桶
    for(int i = 0; i < length; i++){
        //当前数除以区间得出存放桶的位置 减1后得出桶的下标
        int num = (int) (arr[i] / section) - 1;
        if(num < 0){
            num = 0;
        }
        bucketList.get(num).add(arr[i]);
    }

    //桶内排序
    for(int i = 0; i < bucketList.size(); i++){
        //jdk的排序速度当然信得过
        Collections.sort(bucketList.get(i));
    }

    //写入原数组
    int index = 0;
    for(ArrayList<Integer> arrayList : bucketList){
        for(int value : arrayList){
            arr[index] = value;
            index++;
        }
    }
}
```



## 基数排序

**算法思想：**  基数排序是桶排序的扩展，它的基本思想是：将整数按位数切割成不同的数字，然后按每个位数分别比较。具体做法是：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。 

**空间换时间**

**平均时间复杂度： O(d(n+r))** ，r 为基数，d为位数。 

**算法稳定性：稳定**

**图示：**

![img](./imgs/10.gif)

```java
public static void sort(int[] arr){
    int length = arr.length;

    //最大值
    int max = arr[0];
    for(int i = 0;i < length;i++){
        if(arr[i] > max){
            max = arr[i];
        }
    }
    //当前排序位置
    int location = 1;

    //桶列表
    ArrayList<ArrayList<Integer>> bucketList = new ArrayList<>();

    //长度为10 装入余数0-9的数据
    for(int i = 0; i < 10; i++){
        bucketList.add(new ArrayList());
    }

    while(true)
    {
        //判断是否排完
        int dd = (int)Math.pow(10，(location - 1));
        if(max < dd){
            break;
        }

        //数据入桶
        for(int i = 0; i < length; i++)
        {
            //计算余数 放入相应的桶
            int number = ((arr[i] / dd) % 10);
            bucketList.get(number).add(arr[i]);
        }

        //写回数组
        int nn = 0;
        for (int i=0;i<10;i++){
            int size = bucketList.get(i).size();
            for(int ii = 0;ii < size;ii ++){
                arr[nn++] = bucketList.get(i).get(ii);
            }
            bucketList.get(i).clear();
        }
        location++;
    }
}
```



## 计数排序

**算法思想：**  把数组**元素**作为数组的**下标**，然后用一个临时数组统计该元素出现的次数，例如 temp[i] = m, 表示元素 i 一共出现了 m 次。最后再把临时数组统计的数据从小到大汇总起来，此时汇总起来是数据是有序的。 

**空间换时间**

**平均时间复杂度：  O(n)**

**算法稳定性：稳定**

**图示：**

![img](./imgs/11.gif) 

```java
public static void sort(int[] arr) {
    //找出数组中的最大值
    int max = arr[0];
    for (int i = 1; i < arr.length; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }
    //初始化计数数组
    int[] countArr = new int[max + 1];

    //计数
    for (int i = 0; i < arr.length; i++) {
        countArr[arr[i]]++;
        arr[i] = 0;
    }

    //排序
    int index = 0;
    for (int i = 0; i < countArr.length; i++) {
        if (countArr[i] > 0) {
            arr[index++] = i;
        }
    }
}
```





# 查找

- 顺序查找
- 二分查找
- 二叉查找树
- 平衡二叉查找树
- 散列表



## 二分查找

二分查找基于**有序数组**实现。

- **优点：**最优的查找效率和空间需求，能够进行有序性相关的操作。
- **缺点：**插入操作很慢。

在**N个键**的**有序**数组中进行二分查找**最多**需要**（lgN + 1）次比较**（无论是否成功）。



**经典的二分查找：**

```java
import java.util.Arrays;
import java.util.Scanner;
/**
 * 二分查找
 */
public class BinarySearch {
    //key为被查找的值，a为查找的数组,返回值是key在数组a中的索引
    public static int rank(int key,int[] a){
        //传入的数组a[]必须是有序的
        int lo = 0;
        int hi = a.length - 1;
        while(lo <= hi){
            //被查找的key键要么不存在，要么必然存在于a[lo...hi]之中
            int mid = lo + (hi - lo) / 2; //取目前查找范围的中间
            if (key < a[mid]) hi = mid - 1;
            else if (key > a[mid]) lo = mid + 1;
            else return mid;
        }
        return -1;//未查找到key
    }

    //测试代码
    public static void main(String[] args) {
        int[] a = new int[]{48,13,45,75,23,46,765,12,65,67,22,2,43,76};
        Scanner scanner = new Scanner(System.in);
        int key = scanner.nextInt();
        //调用Arrays工具类的sort方法对数组a进行排序
        Arrays.sort(a);
        for (int x : a) {
            System.out.print(x + " ");
        }
        System.out.println();
        int index = rank(key,a);//调用查找方法
        if ( index == -1){
            System.out.println("查询元素不存在！");
        } else{
            System.out.println("所查元素在有序数组中的索引：" + index);
        }
    }
}
```

<img src="C:\Users\王嘉豪\AppData\Roaming\Typora\typora-user-images\1633943814850.png" alt="1633943814850" style="zoom:67%;" />

**递归的二分查找：**

```java
//这个key可以不限于int类型(Key在这是泛型)，因为比较是基于compareTo方法
public int rank(Key key,Key[] a,int lo,int hi){
    if(hi < lo)	return lo;
    int mid = lo + (hi - lo) / 2;
    int cmp = key.compareTo(a[mid]);
    if(cmp < 0)	return rank(key, a, lo, mid - 1);
    else if(cmp > 0)	return rank(key, a, mid + 1, hi);
    else	return mid;
}
```



 

## 二叉查找树

能够将**链表插入的灵活性**和**有序数组查找的高效性**结合起来。

二叉查找树（BST）中**每个结点的键都大于其左子树中的任意结点的键而小于右子树的任意结点的键**。

在二叉查找树中查找一个键的递归算法：如果树是空的，则查找未命中；如果被查找的键和根节点的键相等，查找命中，否则就（递归地）在适当的子树中继续查找。如果被查找的键较小就选择左子树，较大则选择右子树。

对于命中的查找，路径在含有被查找的键的结点处结束。对于未命中的查找，路径的终点是一个空链接。



**BST代码实现：**

```java
/*
二叉查找树中的键继承了Comparable接口，结点的键为Key类型，值为Value类型
*/
public class BST<Key extends Comparable<Key>, Value<{
	
    private Node root;//二叉查找树的根节点
    
    //内部类，树中结点的结构实现
    private class Node{
        private Key key;//键
        private Value val;//值
        private Node left,right;//指向左右子树的链接
        private int N;//以该结点为根的子树中的结点总数
        //有参构造器
        public Node(Key key, Value val, int N){
            this.key = key;
            this.val = val;
            this.N = N;
        }
    }
    
    //整棵二叉查找树树结点的数量
    public int size(){
        return size(root);
    }
    private int size(Node x){//以x为根结点的树的结点数量
        if(x == null)	return 0;
        else	return x.N;
    }
    
    //根据键key获取其对应结点的值val
    public Value get(Key key){	return get(root, key);}
    //在以x为根结点的子树中查找并返回key所对应的值；如果找不到则返回null
    private Value get(Node x, Key key){
		if(x == null)	return null;
        int cmp = key.compareTo(x.key);
        if(cmp < 0 )	return get(x.left, key);
        else if(cmp > 0)	return get(x.right, key);
        else	return	x.val;
    }
    
    //查找某key，找到则更新它的值，否则为它在树中创建一个新的结点
    public void put(Key key, Value val){
        root = (root, key, val);
    }
    //如果key存在于以x为根结点的子树中则更新它的值，否则将以key和val为键值对的新结点插入到该子树中
    private Node put(Node x, Key key, Value val){
        if(x == null)	return new Node(key, val, 1);//找不到该键的结点，创建新结点
        int cmp = key.compareTo(x.key);
        if(cmp < 0)	x.left = put(x.left, key ,val);
        else if(cmp > 0) x.right = put(x.right, key, val);
        else x.val = val;//目前结点的键等于所查键，赋新值
        x.N = size(x.left) + size(x.right) + 1;
        return x;
    }
    
    //查询值最小的结点键
    public Key min(){	return min(root).key; }
    private Node min(Node x){
        if(x.left == null)	return x;
        return min(x.left);
    }
    
    //
}
```





## 散列表查找





## 红黑树









# 字符串匹配算法

字符串匹配，也称子字符串查找：给定一段**长度为 N 的文本(Text)**和一个**长度为 M 的模式(Pattern)**字符串，在文本中找到一个和该模式相符的子字符串。

![img](https://img2018.cnblogs.com/blog/1276550/201910/1276550-20191013104623641-1312127319.png) 

 字符串匹配算法通常分为2个步骤：**预处理**和**匹配**。算法的总运行时间是两者之和。 



## 暴力匹配

就是穷举法，枚举法。是最低效最原始的算法。特点：

1. 无预处理阶段。（因为是暴力匹配）
2. 对 Pattern，可以从 Text 的首或尾开始逐个匹配字母，比较顺序没有限制。
3. 最坏时间复杂度 O((n-m+1)*m).

方法是使用循环来检查是否在范围 n-m+1 中存在满足条件 **P[1..m] = T[s+1..s+m]** 的有效位移 s。

 <img src="https://img2018.cnblogs.com/blog/1276550/201910/1276550-20191013111840306-1966625656.png" alt="img" style="zoom:50%;" /> 

 <img src="https://pic4.zhimg.com/v2-817073ca77f6c75d234392f207a3c81b_b.webp" alt="img" style="zoom:67%;" /> 

**代码实现：**

最笨的暴力匹配，在匹配成功前的txt文本中每一位都参与过比较

```java
public static int search(String txt, String pat){
	int N = txt.length();//文本长度
    int M = pat.length();//模式长度
    //指针i跟踪文本，指针j跟踪模式
    for(int i = 0; i <= N - M; i++){
		int j;
        for(j = 0; j < M; j++){
            if(txt.charAt(i + j) != pat.charAt(j))
                break;
        }
        if(j == M) return i;//找到匹配
    }
    return -1;//未找到匹配
}
```

带显式回退的暴力匹配，如果 i 和 j 指向的字符不匹配了，那么就需要回退这两个指针的值：将 j 重新指向模式的开头，将 i 指向本次匹配的开始位置的下一个字符。

```java
public static int search(String txt, String pat){
	int N = txt.length();//文本长度
    int M = pat.length();//模式长度
    int i,j;
    //指针i跟踪文本，指针j跟踪模式
    for(i = 0,j = 0; i < N && j < M; i++){
		if(txt.charAt(i) == pat.charAt(j)){
           	j++; 
        }else{
       		i = i - j;//
            j = 0;
        }
    }
    if(j == M)	return i - M;//找到匹配
    else	return -1;//未找到匹配
}
```



## KMP

 [labuladong专栏KMP算法详解](https://zhuanlan.zhihu.com/p/83334559)

**代码实现：**

```java
public class KMP {
    private int[][] dp;//保存确定有限状态机的二维数组
    private String pat;//模式字符串

    //由模式字符串构造DFA
    public KMP(String pat) {
        this.pat = pat;
        int M = pat.length();
        // dp[状态][字符] = 下个状态
        dp = new int[M][256];
        // base case
        dp[0][pat.charAt(0)] = 1;
        // 影子状态 X 初始为 0
        int X = 0;
        // 构建状态转移图
        for (int j = 1; j < M; j++) {
            for (int c = 0; c < 256; c++)
                dp[j][c] = dp[X][c];//复制匹配失败情况下的值
            dp[j][pat.charAt(j)] = j + 1;//设置匹配成功情况下的值
            // 更新影子状态
            X = dp[X][pat.charAt(j)];
        }
    }

    public int search(String txt) {
        int M = pat.length();
        int N = txt.length();
        // pat 的初始态为 0
        int j = 0;
        for (int i = 0; i < N; i++) {
            // 计算 pat 的下一个状态
            j = dp[j][txt.charAt(i)];
            // 到达终止态，返回结果
            if (j == M) return i - M + 1;
        }
        // 没到达终止态，匹配失败
        return -1;
    }
}
```



## BM







## Trie





# 操作系统页面置换算法

- **先进先出置换算法（FIFO）**
  - First In First Out，先进先出，和队列保持一致。最先进来的最早出去。 

- **最近最久未使用算法（LRU）**
  - Least Recently Used，最近最少使用。总是淘汰最近没有使用的。其核心思想是**“如果数据最近被访问过，那么将来被访问的几率也更高”**。
    也就是说，淘汰最近一段时间内最长时间未访问过的数据。根据**程序局部性原理**，刚被访问的数据，可能马上又要被访问；而较长时间内没有被访问的数据，可能最近不会被访问。 
- **最佳置换算法（OPT）**
  -  Optimal，最佳置换。置换以后永不再被访问，或者在将来最迟才会被访问的。该算法无法实现，通常作为衡量其他算法的标准。 
- **最不经常使用（LFU）**
  -  Least Frequently Used，最近使用次数最少。即淘汰使用次数最少的。 



**缓存置换算法的要素**

1. 缓存不是无限大，需要有一个固定的大小来约束其大小
2. 缓存满后，再次插入需要替换掉某些元素，才能添加新元素
3. 每次访问完缓存，可能需要改变缓存元素的状态，如元素顺序的改变

***

**Java LinkedHashMap 简介**

先看下`LinkedHashMap`的构造函数，三个参数分别为：**初始化大小**、**装载因子**和**访问顺序**。

- 当参数`accessOrder = true`时，则按照**访问顺序对Map排序**，那么调用`get()`方法后，会将这次访问的元素移至链表尾部。不断访问可以形成按**访问顺序排序**的链表。
- 当参数`accessOrder = false`时，则按照**插入顺序对Map排序**。先插入的元素放置在链表的首部，按照尾插入的方式维护链表。

```java
public LinkedHashMap(int initialCapacity,
                         float loadFactor,
                         boolean accessOrder) {
        super(initialCapacity, loadFactor);
        this.accessOrder = accessOrder;
}
```

根据链表中元素的顺序可以分为：**按插入顺序的链表**(默认，false)，和**按访问顺序的链表**(调用get方法)。默认是按插入顺序排序，如果指定按访问顺序排序，那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。 **可以重写`removeEldestEntry`方法返回true值指定插入元素时移除最老的元素。**

**结论1：可以得出`accessOrder = true`时，可以模仿出LRU的特性；`accessOrder = false`时，可以模仿出FIFO的特性。即满足缓存置换算法要素3。**

这是LinkedHashMap中另外一个方法：移除最久的元素。当返回为false时，不会移除其中最久的元素。当返回true的时候，就会remove其中最久的元素。

```java
protected boolean removeEldestEntry(Map.Entry<K,V> eldest) {
        return false;
}
```

**结论2：由于缓存置换算法要素2，当缓存满了之后，需通过返回`true`删除最久未被使用的元素。所以我们需要 重写此方法来删除缓存元素，达到缓存置换的要求。**

当然，我们还需要满足缓存置换算法要素1，就大功告成了。由于Java Map是自动扩容的，当其`table.size() > Capacity * loadFactor`的时，会自动进行两倍扩容。

**结论：为了使缓存能固定大小，需要禁止Map的自动扩容。可将初始化大小设置为`(cacheSize / loadFactor) + 1`，就可以在元素数目达到缓存大小时，不会自动扩容，达到缓存置换的要求。**

***



## 先进先出置换算法（FIFO）

> 选择最先进入内存的页面进行置换，即在内存中驻留时间最长的页面要被淘汰。
>
> 该算法的核心思想是：最早调入内存的页，其不再被使用的可能性比刚调入内存的可能性大。

![img](https://upload-images.jianshu.io/upload_images/7632302-775ee3ac3a6d7421.png?imageMogr2/auto-orient/strip|imageView2/2/w/618/format/webp) 

**实现思路：**

> 设置一个指针始终指向**最早进入内存块序列**的内存块，并保持动态更新。
>
> 也可以使用 Java 的 LinkedHashMap 实现。 

**具体代码：**

**借助于 LinkedHashMap 实现 FIFO**

```java
public class FIFOCached<K, V> {
 
    private final int MAX_CACHE_SIZE;//最大缓存空间
    private final float DEFAULT_LOAD_FACTORY = 0.75f;//用于构造LinkedHashMap的装载因子

    LinkedHashMap<K, V> map;//使用LinkedHashMap存放页

    public FIFOCached(int cacheSize) {
        MAX_CACHE_SIZE = cacheSize;
        //初始化大小设置为(cacheSize / loadFactor) + 1，避免map自动扩容
        int capacity = (int)Math.ceil(MAX_CACHE_SIZE / DEFAULT_LOAD_FACTORY) + 1;
        /*
         * 第三个参数设置为true，代表linkedlist按访问顺序排序，可作为LRU缓存
         * 第三个参数设置为false，代表按插入顺序排序，可作为FIFO缓存
         */
        map = new LinkedHashMap<K, V>(capacity, DEFAULT_LOAD_FACTORY, false) {
            @Override
            protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
                return size() > MAX_CACHE_SIZE; // 删除最前的元素
            }
        };
    }
}
```

**根据LinkedHashMap重新实现**

由于LinkedHashMap并非是线程安全的，我们可以仅利用LinkedHashMap的特性自己实现一个。

```java
public class FIFOCache<K, V> {
    private static int MAX_CACHE_SIZE = 0;
    private final float LOAD_FACTORY = 0.75f;

    Map<K, V> map;

    public FIFOCache(int maxCacheSize) {
        this.MAX_CACHE_SIZE = maxCacheSize;
        // 根据 cacheSize 和 填充因子 计算cache的容量
        int capacity = (int) Math.ceil(MAX_CACHE_SIZE / LOAD_FACTORY) + 1;
        map = new LinkedHashMap<K, V>(capacity, LOAD_FACTORY, false) {
            @Override
            protected boolean removeEldestEntry(Map.Entry eldest) {
                return size() > MAX_CACHE_SIZE;
            }
        };
    }

    //下列方法加锁使线程同步
    public synchronized void put(K key, V value) {
        map.put(key, value);
    }

    public synchronized V get(K key) {
        return map.get(key);
    }

    public synchronized void remove(K key) {
        map.remove(key);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        for (Map.Entry<K, V> entry : map.entrySet()) {
            sb.append(entry.getKey()).append("=")
                    .append(entry.getValue()).append(" ");
        }
        return sb.toString();
    }
}
```





## 最近最久未使用算法（LRU）

> 选择最近一段时间内最长时间没有被访问过的页面进行置换。
>
> 该算法根据数据的历史访问记录来进行淘汰数据，其核心思想是：如果数据最近被访问过，那么将来被访问的几率也更高。

![img](https://upload-images.jianshu.io/upload_images/7632302-147c2f801f0e8254.png?imageMogr2/auto-orient/strip|imageView2/2/w/609/format/webp) 

**实现思路：**

> 可以使用**双向链表+哈希表**来实现：
>
> 当访问到新的（不位于当前内存块序列中）内存块时（即缺页），将其插入到链表首部；
> 如果当前内存块序列中某个内存块被命中（被使用到），则将其移到链表首部；
> 为链表设置一个容量（设为分配给该程序的内存块数），当超出这个容量时，丢弃链表尾部的内存块。
> 剩下的哈希表用来查找内存块。
> 实际上，Java已经为我们提供这种结构了！—— **LinkedHashMap**
>
> 我们主要将其中的**accessOrder**设置为true，保证了LinkedHashMap底层实现的双向链表是按照访问的先后顺序排序。

**具体代码：**

**借助于 LinkedHashMap 实现 LRU**

```java
public class Cache<K, V> extends LinkedHashMap<K, V> {
    private static int MAX_CACHE_SIZE;//最大缓存空间

    public Cache(int maxCacheSize) {
        //初始化大小设置为(cacheSize / loadFactor) + 1，避免map自动扩容
        super((int) Math.ceil(maxCacheSize / 0.75) + 1, 0.75f, true);
        this.MAX_CACHE_SIZE = maxCacheSize;
    }

    @Override
    public boolean removeEldestEntry(Map.Entry eldest) {
        return size() > MAX_CACHE_SIZE; // 需要删除最久的元素
    }
}
```

**根据LinkedHashMap重新实现**

同样，由于LinkedHashMap并非是线程安全的，我们可以仅利用LinkedHashMap的特性自己实现一个。
和FIFO的实现基本一致，只需要将`accessOrder = true`。

```java
public class LruCache<K, V> {
    private static int MAX_CACHE_SIZE = 0;
    private final float LOAD_FACTORY = 0.75f;

    Map<K, V> map;

    public LruCache(int maxCacheSize) {
        this.MAX_CACHE_SIZE = maxCacheSize;
        // 根据 cacheSize 和 填充因子计算cache的容量
        int capacity = (int) Math.ceil(MAX_CACHE_SIZE / LOAD_FACTORY) + 1;
        map = new LinkedHashMap<K, V>(capacity, LOAD_FACTORY, true) {
            @Override
            protected boolean removeEldestEntry(Map.Entry eldest) {
                return size() > MAX_CACHE_SIZE;
            }
        };
    }

    //下列方法加锁使线程同步
    public synchronized void put(K key, V value) {
        map.put(key, value);
    }

    public synchronized V get(K key) {
        return map.get(key);
    }

    public synchronized void remove(K key) {
        map.remove(key);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        for (Map.Entry<K, V> entry : map.entrySet()) {
            sb.append(entry.getKey()).append("=")
                    .append(entry.getValue()).append(" ");
        }
        return sb.toString();
    }
}
```







# 剑指Offer题解



## [剑指 Offer 03. 数组中重复的数字](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)【简单】

找出数组中重复的数字。


在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

**示例 1：**

```
输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3 
```

**限制：**

- 2 <= n <= 100000

**我的思路：**

用一个集合来逐个添加数组的元素，只要这个元素已经在集合中添加过了，就证明这个元素是重复的。

```java
class Solution {
    public int findRepeatNumber(int[] nums) {
        Set<Integer> set = new HashSet<>();
        for(int i = 0;i < nums.length;i++){
            if(set.contains(nums[i])){//集合已存在此元素，返回此元素
               return nums[i]; 
            }
            set.add(nums[i]);//如果目前集合中没有此元素，则添加进集合
        }
        return -1;//程序不会运行到这，因为一定有重复元素，这里只是防止运行时错误
    }
}
```

**其他答案：**

巧妙利用辅助数组记录

```java
class Solution {
    public int findRepeatNumber(int[] nums) {
        boolean[] isrepeat = new boolean[nums.length];
        for(int num : nums){
            if(isrepeat[num]){
                return num;
            }
            isrepeat[num] = true;
        }
        return -1;
    }
}
```





## [剑指 Offer 05. 替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)【简单】

请实现一个函数，把字符串 s 中的每个空格替换成"%20"。

**示例 1：**

```
输入：s = "We are happy."
输出："We%20are%20happy."
```

**限制：**

- 0 <= s 的长度 <= 10000




```java
class Solution {
    public String replaceSpace(String s) {
        String s1 = "";
        for(int i = 0;i < s.length();i++){
            if(s.charAt(i) == ' '){
                s1 += "%20";
            }else{
                s1 += s.charAt(i);
            }      
        }
        return s1;
    }
}
```

**其他思路：**

```java
class Solution {
    public String replaceSpace(String s) {
        StringBuilder sb = new StringBuilder();
        for(int i = 0 ; i < s.length(); i++){
            char c = s.charAt(i);
            if(c == ' ') sb.append("%20");
            else sb.append(c);
        }
        return sb.toString();
    }
}
```





## [剑指 Offer 06. 从尾到头打印链表](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)【简单】

输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 

**示例 1：**

```
输入：head = [1,3,2]
输出：[2,3,1]
```

**限制：**

- 0 <= 链表长度 <= 10000




```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public int[] reversePrint(ListNode head) {
        List<Integer> list = new ArrayList<>();
        while(head != null){
            list.add(head.val);//把每个节点的值逐一放入
            head = head.next;
        }
        int[] arr = new int[list.size()];
        int i = list.size() - 1;
        for(int e : list){ //将列表中的值倒序赋给数组
            arr[i] = e;
            i--;
        }
        return arr;
    }
}
```





## [剑指 Offer 09. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)【简单】

用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )

**示例 1：**

```
输入：
["CQueue","appendTail","deleteHead","deleteHead"]
[[],[3],[],[]]
输出：[null,null,3,-1]
```

**示例 2：**

```
输入：
["CQueue","deleteHead","appendTail","appendTail","deleteHead","deleteHead"]
[[],[],[5],[2],[],[]]
输出：[null,-1,null,null,5,2]
```

**提示：**

- 1 <= values <= 10000
- 最多会对 appendTail、deleteHead 进行 10000 次调用



**我的思路：**

分别构造两个链表（栈）A和B，插入新元素时都逐个往A链表末尾插入，当要取出队列头的元素时，将A链表中的元素从后到前（即先入后出弹栈）拿出并插入B链表，此时B链表中的最后一个元素就是队列头元素，取出头元素后再把元素逐一放回A链表。

```java
class CQueue {

    LinkedList<Integer> A,B;//用两个链表作为两个栈

    public CQueue() {
        A = new LinkedList<Integer>();//保存进队列的元素
        B = new LinkedList<Integer>();//出队列时作为辅助
    }
    
    public void appendTail(int value) {
        A.add(value);
    }
    
    public int deleteHead() {
        if(A.isEmpty()) return -1;
        while(!A.isEmpty()){//将A中元素全部从后往前装载进B
            B.add(A.removeLast());
        }
        int ans = B.removeLast();//取得A中第一个元素，即队列头
        while(!B.isEmpty()){
            A.add(B.removeLast());//将B中元素原路放回A，除了弹出的队列头
        }
        return ans;//返回队列头元素
    }
}

/**
 * Your CQueue object will be instantiated and called as such:
 * CQueue obj = new CQueue();
 * obj.appendTail(value);
 * int param_2 = obj.deleteHead();
 */
```

**其他思路：**

其实不需要像我上面的代码一样将B栈中元素返回给A栈

```java
class CQueue {
    LinkedList<Integer> A, B;
    public CQueue() {
        A = new LinkedList<Integer>();
        B = new LinkedList<Integer>();
    }
    public void appendTail(int value) {
        A.addLast(value);
    }
    public int deleteHead() {
        if(!B.isEmpty()) return B.removeLast();
        if(A.isEmpty()) return -1;
        while(!A.isEmpty())
            B.addLast(A.removeLast());
        return B.removeLast();
    }
}
```





## [剑指 Offer 11. 旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)【简单】

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  

**示例 1：**

```
输入：[3,4,5,1,2]
输出：1
```

**示例 2：**

```
输入：[2,2,2,0,1]
输出：0
```

**我的思路：**

利用二分法，如果mid元素比hi元素大，则证明目前mid在旋转数组左边较大的序列上，需要让mid右移；如果mid元素比hi元素小，证明目前mid在旋转数组右边较小的序列上，此时应该让mid左移，最终可得出最小元素的索引 lo。

```java
class Solution {
    public int minArray(int[] numbers) {
        int lo = 0, hi = numbers.length-1;
        int mid = 0;
        while(lo <= hi){
            mid = lo + (hi - lo)/2;
            if(numbers[mid] < numbers[hi]){
                hi = mid;//中间比右边小，证明中间落在了旋转后的右半数组，应该让mid前移
            } else if(numbers[mid] > numbers[hi]){
                lo = mid + 1;//中间比右边大，则此时最小元素应该在右边，应该让mid右移
            } else{
                hi--;//使得mid移动，剔除重复的元素
            }
        }
        return numbers[lo];
    }
}
```

**其他思路：**

时间复杂度较高，利用Arrays.sort()方法排序好数组再取数组索引为0的元素即可

```java
class Solution {
    public int minArray(int[] numbers) {
        Arrays.sort(numbers);
        return numbers[0];
    }
}
```





## [剑指 Offer 24. 反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)【简单】

定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

**示例:**

```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

**限制：**

- 0 <= 节点个数 <= 5000


**我的思路：**

迭代法，想要反转一个单链表，必须保留着当前元素的前后驱元素的指针不丢失，所以需要定义三个ListNode变量分别保存这三个重要节点，在一个循环中不断将三个节点后移并改变它们的前后驱指向，实现链表的反转。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head == null || head.next == null){
            return head;
        }
        ListNode prev = null;//指向当前元素的前驱元素
        ListNode now = head;//指向当前元素
        ListNode next = null;//指向当前元素的后驱元素，避免丢失后驱元素
        while(now != null){
            next = now.next;//取后驱元素
            
            now.next = prev;//反转当前元素和前驱元素顺序
            prev = now;//前驱元素后移至当前元素位置
            now = next;//当前元素后移至后驱元素位置
        }
        return prev;//由于最后一次循环会使node指向Null,所以返回前驱元素
    }
}
```

**其他思路：**

借助栈这一数据结构先进后出的特性，使得链表元素顺序反转。

```java
class Solution {
	public ListNode reverseList_stack(ListNode head) {
        if (head == null) return head;
        Stack<ListNode> stack = new Stack<>();//构造一个空栈
        while (head!=null){
            stack.push(head);//将链表中所有元素逐个压入栈
            head = head.next;
        }
        ListNode newHead = stack.pop();//弹出栈顶元素(原来的链表尾)作为新链表头
        ListNode tailNode = newHead;//用来临时存放当前节点
        //进行链表前后顺序的反转
        while (!stack.isEmpty()){
            ListNode cur =  stack.pop();
            tailNode.next = cur;
            tailNode = cur;
        }
        tailNode.next = null;//给反转后的链表设置新尾元素的下一个元素为null
        return newHead;//返回新表头
    }
}
```





## [剑指 Offer 30. 包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/)【简单】

定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。

**示例:**

```
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.min();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.min();   --> 返回 -2.
```

**提示：**

- 各函数的调用总次数不超过 20000 次




**我的思路：**

直接使用java已有的栈Stack数据结构，使用两个栈satck1和stack2，其中stack1用于存放所有入栈的元素，而stack2用作辅助栈，将每个阶段的最小元素压入栈作为栈顶，这样就实现了用栈来将每个阶段的最小元素保存，调用min只需使用Stack的peek()方法返回stack2的栈顶就行，之后如果pop刚好弹出当前的最小元素，也能在stack2中将其同步弹出删除。

```java
class MinStack {

    Stack<Integer> stack1;//存放所有存入栈的元素
    Stack<Integer> stack2;//辅助栈，存放最小元素，只要新加入的元素更小(或等于当前栈顶元素)，就入栈(成为新栈顶)

    /** initialize your data structure here. */
    public MinStack() {
        stack1 = new Stack<Integer>();
        stack2 = new Stack<Integer>();
    }
    
    public void push(int x) {
        stack1.push(x);
        //若栈中没有元素或此时栈顶元素小于新加入的元素，则新加入元素即为最小元素
        if(stack2.empty() || x <= stack2.peek()){
            stack2.push(x);
        }
    }
    
    public void pop() {
        int tmp = stack1.pop();
        if(tmp == stack2.peek()) stack2.pop();//若弹出元素和辅助栈栈顶元素相同，辅助栈也弹栈
    }
    
    public int top() {
        return stack1.peek();//这个方法可以直接返回栈顶但不删除
    }
    
    public int min() {
        return stack2.peek();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.min();
 */
```





## [剑指 Offer 35. 复杂链表的复制](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/)【中等】

请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png) 

```
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png) 

```
输入：head = [[1,1],[2,1]]
输出：[[1,1],[2,1]]
```

**示例 3：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png) 

```
输入：head = [[3,null],[3,0],[3,null]]
输出：[[3,null],[3,0],[3,null]]
```

**示例 4：**

```
输入：head = []
输出：[]
解释：给定的链表为空（空指针），因此返回 null。
```

**提示：**

- -10000 <= Node.val <= 10000
- Node.random 为空（null）或指向链表中的节点。
- 节点数目不超过 1000 。

> **未ac**，没看懂题目

**其他思路：**

题目其实就是要实现对一个复杂链表的深拷贝，并不是简单地引用这个链表的同个地址，保证复制出来的新链表每个节点都是新的。

**本题难点：** 在复制链表的过程中构建新链表各节点的 `random` 引用指向。 

**方法一：哈希表**

利用哈希表的查询特点，考虑构建 **原链表节点** 和 **新链表对应节点** 的键值对映射关系，再遍历构建新链表各节点的 `next` 和 `random` 引用指向即可。

**算法流程：**

1. 若头节点 `head` 为空节点，直接返回 `null` ；

2. 初始化： 哈希表 `map` ， 节点 `cur` 指向头节点；

3. 复制链表：
   1. 建立新节点，并向 `map` 添加键值对 `(原 cur 节点, 新 cur 节点)` ；
   2. `cur` 遍历至原链表下一节点；

4. 构建新链表的引用指向：

   1. 构建新节点的 `next` 和 `random` 引用指向；

   2. `cur` 遍历至原链表下一节点；

5. 返回值： 新链表的头节点 `map[cur]` ；

**复杂度分析：**

- 时间复杂度 O(N) ： 两轮遍历链表，使用 O(N) 时间。
- 空间复杂度 O(N) ： 哈希表 map 使用线性大小的额外空间。

```java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/
class Solution {
    public Node copyRandomList(Node head) {//利用哈希表实现复杂链表深拷贝
        if(head == null)    return null;
        Map<Node,Node> map = new HashMap<>();
        Node cur = head;
        //复制各节点，并建立 “原节点 -> 新节点” 的 Map 映射
        while(cur != null){
            map.put(cur,new Node(cur.val));
            cur = cur.next;
        }
        cur = head;
        //构建新链表(难点)
        while(cur != null){
            //注意这里"="右边千万不能写成 cur.next/cur.random，不然还是浅拷贝
            map.get(cur).next = map.get(cur.next);
            map.get(cur).random = map.get(cur.random);
            cur = cur.next;
        }
        return map.get(head);
    }
}
```



**方法二：拼接 + 拆分**

![1633959218384](C:\Users\王嘉豪\AppData\Roaming\Typora\typora-user-images\1633959218384.png)

```java
class Solution {
    public Node copyRandomList(Node head) {
        if(head == null) return null;
        Node cur = head;
        // 1. 复制各节点，并构建拼接链表
        while(cur != null) {
            Node tmp = new Node(cur.val);
            tmp.next = cur.next;
            cur.next = tmp;
            cur = tmp.next;
        }
        // 2. 构建各新节点的 random 指向
        cur = head;
        while(cur != null) {
            if(cur.random != null)
                cur.next.random = cur.random.next;
            cur = cur.next.next;
        }
        // 3. 拆分两链表
        cur = head.next;
        Node pre = head, res = head.next;
        while(cur.next != null) {
            pre.next = pre.next.next;
            cur.next = cur.next.next;
            pre = pre.next;
            cur = cur.next;
        }
        pre.next = null; // 单独处理原链表尾节点
        return res;      // 返回新链表头节点
    }
}
```





## [剑指 Offer 50. 第一个只出现一次的字符](https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/)【简单】

在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。

**示例 1:**

```
输入：s = "abaccdeff"
输出：'b'
```

**示例 2:**

```
输入：s = "" 
输出：' '
```

**限制：**

- 0 <= s 的长度 <= 50000


**我的思路：**

用哈希表保存字符及其对应出现次数，再遍历查找只出现过一次的字符。（时间空间复杂度都过高）

```java
class Solution {
    public char firstUniqChar(String s) {
        char[] c = s.toCharArray();
        Map<Character,Integer> map = new HashMap<>();//用map保存字符和对应次数
        for(int i = 0;i < s.length();i++){
            if(map.get(c[i]) != null){
                int num = map.get(c[i]);
                num++;
                map.put(c[i],num);
            }else{//避免第一次获取到null值导致空指针异常
                map.put(c[i],1);
            }
        }
        int j;
        for(j = 0;j < s.length();j++){
            if(map.get(c[j]) == 1){//找到出现次数只有一次的字符
                break;
            }
        }
        if(j == s.length()) return ' ';//找不到出现次数只有一次的字符
        return c[j];
    }
}
```

**其他思路：**

使用字典查找

```java
class Solution {	
	public char firstUniqChar(String s) {
        if (s.equals("")) return ' ';
        //创建‘a'-'z'的字典
        int[] target = new int[26];
        //第一次遍历，将字符统计到字典数组
        for (int i = 0; i < s.length(); i++) {
            target[s.charAt(i) - 'a']++;
        }
        //第二次遍历，从字典数组获取次数
        for (int i = 0; i < s.length(); i++) {
            if (target[s.charAt(i) - 'a'] == 1) return s.charAt(i);
        }

        return ' ';//没有只出现一次的字母
    }
}
```

哈希表优化

```java
class Solution {
    public char firstUniqChar(String s) {
        HashMap<Character, Boolean> dic = new HashMap<>();
        char[] sc = s.toCharArray();
        for(char c : sc)
            dic.put(c, !dic.containsKey(c));//当一个字符出现了一次以上，value就会被设定为false
        for(char c : sc)
            if(dic.get(c)) return c;
        return ' ';
    }
}
```

有序哈希表

在哈希表的基础上，有序哈希表中的键值对是 **按照插入顺序排序** 的。基于此，可通过遍历有序哈希表，实现搜索首个 “数量为 1 的字符”。

哈希表是 **去重** 的，即哈希表中键值对数量 ≤ 字符串 s 的长度。因此，相比于普通哈希表，有序哈希表减少了第二轮遍历的循环次数。当字符串很长（重复字符很多）时，有序哈希表则效率更高。

 Java 使用 `LinkedHashMap` 实现有序哈希表。 

```java
class Solution {
    public char firstUniqChar(String s) {
        Map<Character, Boolean> dic = new LinkedHashMap<>();
        char[] sc = s.toCharArray();
        for(char c : sc)
            dic.put(c, !dic.containsKey(c));
        for(Map.Entry<Character, Boolean> d : dic.entrySet()){
           if(d.getValue()) return d.getKey();
        }
        return ' ';
    }
}
```





## [剑指 Offer 53 - I. 在排序数组中查找数字 I](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)【简单】

统计一个数字在排序数组中出现的次数。

**示例 1:**

```
输入: nums = [5,7,7,8,8,10], target = 8
输出: 2
```

**示例 2:**

```
输入: nums = [5,7,7,8,8,10], target = 6
输出: 0
```

**提示：**

- 0 <= nums.length <= 10^5
- -109^9<= nums[i] <= 10^9
- nums 是一个非递减数组
- -10^9 <= target <= 10^9

**我的思路：**

暴力解法，没有用到排序数组这一性质

```java
class Solution {
    public int search(int[] nums, int target) {
        int num = 0;
        for(int i = 0;i < nums.length;i++){
            if(target == nums[i]){
                num++;
            }
        }
        return num;
    }
}
```

使用二分查找找出target在有序数组中的位置，然后前后遍历数组找这个数字出现的次数

```java
class Solution {
    public int search(int[] nums, int target) {

        int num = 0;//记录数字出现的次数
        int i = binarySearch(target,nums,0,nums.length-1);
        if(i == -1) return 0;//不存在该数字，返回0
        int j = i;
        while(j >= 0 && nums[j] == target){
            num++;
            j--;//向左遍历
        }
        i++;//i位置上的已经加上了
        while(i <= nums.length-1 && nums[i] == target){
            num++;
            i++;//向右遍历
        }
        return num;
    }

    //二分法查找target在数组的位置
    int binarySearch(int target, int[] nums, int lo, int hi){
        while(lo <= hi){
            int mid = lo + (hi - lo)/2;
            if(target < nums[mid]) hi = mid - 1;
            else if(target > nums[mid]) lo = mid + 1;
            else return mid;
        }
        return -1;
    }
}
```

优化一下：

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0,right = nums.length - 1;
        int count = 0;
        while(left < right){
            int mid = (left + right) / 2;
            if(nums[mid] >= target)
                right = mid;
            if(nums[mid] < target)
                left = mid + 1;
        }
        while(left < nums.length && nums[left++] == target)
            count++;
        return count;
    }
}
```





## [剑指 Offer 53 - II. 0～n-1中缺失的数字](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/)【简单】

一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。

**示例 1:**

```
输入: [0,1,3]
输出: 2
```

**示例 2:**

```
输入: [0,1,2,3,4,5,6,7,9]
输出: 8
```

**限制：**

- 1 <= 数组长度 <= 10000

**我的思路：**

暴力迭代法（略）

使用二分法查找缺失的数字所在区间位置

```java
class Solution {
    public int missingNumber(int[] nums) {
        int lo = 0, hi = nums.length - 1;
        int mid = 0;
        while(lo <= hi){
            mid = lo + (hi - lo)/2;
            if(nums[mid] == mid) lo = mid + 1;//缺失数字在后半部分
            else hi = mid - 1;//缺失数字在前半部分
        } 
        return lo;
    }
}          
```







## [剑指 Offer 58 - II. 左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)【简单】

字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。

**示例 1：**

```
输入: s = "abcdefg", k = 2
输出: "cdefgab"
```

示例 2：

```
输入: s = "lrloseumgh", k = 6
输出: "umghlrlose"
```


限制：

- 1 <= k < s.length <= 10000

**我的思路：**

直接调用java的字符串处理api，分别取两部分子串，再进行拼接。

```java
class Solution {
    public String reverseLeftWords(String s, int n) {
        String s1 = s.substring(0,n); 
        String s2 = s.substring(n);
        return s2.concat(s1);
    }
}
```

**其他思路：**

 为了让本题更有意义，提升一下本题难度：不能申请额外空间，只能在本串上操作。 

具体步骤为：

1. 反转区间为前n的子串
2. 反转区间为n到末尾的子串
3. 反转整个字符串

最后就可以得到左旋n的目的，而不用定义新的字符串，完全在本串上操作。

```java
class Solution {
    public String reverseLeftWords(String s, int n) {
        int len=s.length();
        StringBuilder sb=new StringBuilder(s);
        reverseString(sb,0,n-1);//反转区间为前n的子串
        reverseString(sb,n,len-1);//反转区间为n到末尾的子串
        return sb.reverse().toString();//反转整个字符串
    }
     public void reverseString(StringBuilder sb, int start, int end) {
        while (start < end) {
            char temp = sb.charAt(start);
            sb.setCharAt(start, sb.charAt(end));
            sb.setCharAt(end, temp);
            start++;
            end--;
            }
        }
}
```

 

