# 算法刷题笔记

> 本算法刷题笔记主要是本人在刷 **LeetCode** 以及 **剑指Offer** 的题目时的刷题思路以及题解
>
> 题目全都标明了难度，点击题目即可跳转至力扣对应处，LeetCode 题目部分分类汇总（这里参考了卡哥的代码随想录的目录结构）~

[toc]



# 剑指 Offer 题解



## [剑指 Offer 03. 数组中重复的数字](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)【简单】

找出数组中重复的数字。


在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

**示例 1：**

```
输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3 
```

**限制：**

- 2 <= n <= 100000

**我的思路：**

用一个集合来逐个添加数组的元素，只要这个元素已经在集合中添加过了，就证明这个元素是重复的。

```java
class Solution {
    public int findRepeatNumber(int[] nums) {
        Set<Integer> set = new HashSet<>();
        for(int i = 0;i < nums.length;i++){
            if(set.contains(nums[i])){//集合已存在此元素，返回此元素
               return nums[i]; 
            }
            set.add(nums[i]);//如果目前集合中没有此元素，则添加进集合
        }
        return -1;//程序不会运行到这，因为一定有重复元素，这里只是防止运行时错误
    }
}
```

**其他答案：**

巧妙利用辅助数组记录

```java
class Solution {
    public int findRepeatNumber(int[] nums) {
        boolean[] isrepeat = new boolean[nums.length];
        for(int num : nums){
            if(isrepeat[num]){
                return num;
            }
            isrepeat[num] = true;
        }
        return -1;
    }
}
```





## [剑指 Offer 05. 替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)【简单】

请实现一个函数，把字符串 s 中的每个空格替换成"%20"。

**示例 1：**

```
输入：s = "We are happy."
输出："We%20are%20happy."
```

**限制：**

- 0 <= s 的长度 <= 10000




```java
class Solution {
    public String replaceSpace(String s) {
        String s1 = "";
        for(int i = 0;i < s.length();i++){
            if(s.charAt(i) == ' '){
                s1 += "%20";
            }else{
                s1 += s.charAt(i);
            }      
        }
        return s1;
    }
}
```

**其他思路：**

```java
class Solution {
    public String replaceSpace(String s) {
        StringBuilder sb = new StringBuilder();
        for(int i = 0 ; i < s.length(); i++){
            char c = s.charAt(i);
            if(c == ' ') sb.append("%20");
            else sb.append(c);
        }
        return sb.toString();
    }
}
```





## [剑指 Offer 06. 从尾到头打印链表](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)【简单】

输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 

**示例 1：**

```
输入：head = [1,3,2]
输出：[2,3,1]
```

**限制：**

- 0 <= 链表长度 <= 10000




```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public int[] reversePrint(ListNode head) {
        List<Integer> list = new ArrayList<>();
        while(head != null){
            list.add(head.val);//把每个节点的值逐一放入
            head = head.next;
        }
        int[] arr = new int[list.size()];
        int i = list.size() - 1;
        for(int e : list){ //将列表中的值倒序赋给数组
            arr[i] = e;
            i--;
        }
        return arr;
    }
}
```





## [剑指 Offer 09. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)【简单】

用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )

**示例 1：**

```
输入：
["CQueue","appendTail","deleteHead","deleteHead"]
[[],[3],[],[]]
输出：[null,null,3,-1]
```

**示例 2：**

```
输入：
["CQueue","deleteHead","appendTail","appendTail","deleteHead","deleteHead"]
[[],[],[5],[2],[],[]]
输出：[null,-1,null,null,5,2]
```

**提示：**

- 1 <= values <= 10000
- 最多会对 appendTail、deleteHead 进行 10000 次调用



**我的思路：**

分别构造两个链表（栈）A和B，插入新元素时都逐个往A链表末尾插入，当要取出队列头的元素时，将A链表中的元素从后到前（即先入后出弹栈）拿出并插入B链表，此时B链表中的最后一个元素就是队列头元素，取出头元素后再把元素逐一放回A链表。

```java
class CQueue {

    LinkedList<Integer> A,B;//用两个链表作为两个栈

    public CQueue() {
        A = new LinkedList<Integer>();//保存进队列的元素
        B = new LinkedList<Integer>();//出队列时作为辅助
    }
    
    public void appendTail(int value) {
        A.add(value);
    }
    
    public int deleteHead() {
        if(A.isEmpty()) return -1;
        while(!A.isEmpty()){//将A中元素全部从后往前装载进B
            B.add(A.removeLast());
        }
        int ans = B.removeLast();//取得A中第一个元素，即队列头
        while(!B.isEmpty()){
            A.add(B.removeLast());//将B中元素原路放回A，除了弹出的队列头
        }
        return ans;//返回队列头元素
    }
}

/**
 * Your CQueue object will be instantiated and called as such:
 * CQueue obj = new CQueue();
 * obj.appendTail(value);
 * int param_2 = obj.deleteHead();
 */
```

**其他思路：**

其实不需要像我上面的代码一样将B栈中元素返回给A栈

```java
class CQueue {
    LinkedList<Integer> A, B;
    public CQueue() {
        A = new LinkedList<Integer>();
        B = new LinkedList<Integer>();
    }
    public void appendTail(int value) {
        A.addLast(value);
    }
    public int deleteHead() {
        if(!B.isEmpty()) return B.removeLast();
        if(A.isEmpty()) return -1;
        while(!A.isEmpty())
            B.addLast(A.removeLast());
        return B.removeLast();
    }
}
```





## [剑指 Offer 11. 旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)【简单】

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  

**示例 1：**

```
输入：[3,4,5,1,2]
输出：1
```

**示例 2：**

```
输入：[2,2,2,0,1]
输出：0
```

**我的思路：**

利用二分法，如果mid元素比hi元素大，则证明目前mid在旋转数组左边较大的序列上，需要让mid右移；如果mid元素比hi元素小，证明目前mid在旋转数组右边较小的序列上，此时应该让mid左移，最终可得出最小元素的索引 lo。

```java
class Solution {
    public int minArray(int[] numbers) {
        int lo = 0, hi = numbers.length-1;
        int mid = 0;
        while(lo <= hi){
            mid = lo + (hi - lo)/2;
            if(numbers[mid] < numbers[hi]){
                hi = mid;//中间比右边小，证明中间落在了旋转后的右半数组，应该让mid前移
            } else if(numbers[mid] > numbers[hi]){
                lo = mid + 1;//中间比右边大，则此时最小元素应该在右边，应该让mid右移
            } else{
                hi--;//使得mid移动，剔除重复的元素
            }
        }
        return numbers[lo];
    }
}
```

**其他思路：**

时间复杂度较高，利用Arrays.sort()方法排序好数组再取数组索引为0的元素即可

```java
class Solution {
    public int minArray(int[] numbers) {
        Arrays.sort(numbers);
        return numbers[0];
    }
}
```





## [剑指 Offer 24. 反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)【简单】

定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

**示例:**

```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

**限制：**

- 0 <= 节点个数 <= 5000


**我的思路：**

迭代法，想要反转一个单链表，必须保留着当前元素的前后驱元素的指针不丢失，所以需要定义三个ListNode变量分别保存这三个重要节点，在一个循环中不断将三个节点后移并改变它们的前后驱指向，实现链表的反转。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head == null || head.next == null){
            return head;
        }
        ListNode prev = null;//指向当前元素的前驱元素
        ListNode now = head;//指向当前元素
        ListNode next = null;//指向当前元素的后驱元素，避免丢失后驱元素
        while(now != null){
            next = now.next;//取后驱元素
            
            now.next = prev;//反转当前元素和前驱元素顺序
            prev = now;//前驱元素后移至当前元素位置
            now = next;//当前元素后移至后驱元素位置
        }
        return prev;//由于最后一次循环会使node指向Null,所以返回前驱元素
    }
}
```

**其他思路：**

借助栈这一数据结构先进后出的特性，使得链表元素顺序反转。

```java
class Solution {
	public ListNode reverseList_stack(ListNode head) {
        if (head == null) return head;
        Stack<ListNode> stack = new Stack<>();//构造一个空栈
        while (head!=null){
            stack.push(head);//将链表中所有元素逐个压入栈
            head = head.next;
        }
        ListNode newHead = stack.pop();//弹出栈顶元素(原来的链表尾)作为新链表头
        ListNode tailNode = newHead;//用来临时存放当前节点
        //进行链表前后顺序的反转
        while (!stack.isEmpty()){
            ListNode cur =  stack.pop();
            tailNode.next = cur;
            tailNode = cur;
        }
        tailNode.next = null;//给反转后的链表设置新尾元素的下一个元素为null
        return newHead;//返回新表头
    }
}
```





## [剑指 Offer 30. 包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/)【简单】

定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。

**示例:**

```
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.min();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.min();   --> 返回 -2.
```

**提示：**

- 各函数的调用总次数不超过 20000 次




**我的思路：**

直接使用java已有的栈Stack数据结构，使用两个栈satck1和stack2，其中stack1用于存放所有入栈的元素，而stack2用作辅助栈，将每个阶段的最小元素压入栈作为栈顶，这样就实现了用栈来将每个阶段的最小元素保存，调用min只需使用Stack的peek()方法返回stack2的栈顶就行，之后如果pop刚好弹出当前的最小元素，也能在stack2中将其同步弹出删除。

```java
class MinStack {

    Stack<Integer> stack1;//存放所有存入栈的元素
    Stack<Integer> stack2;//辅助栈，存放最小元素，只要新加入的元素更小(或等于当前栈顶元素)，就入栈(成为新栈顶)

    /** initialize your data structure here. */
    public MinStack() {
        stack1 = new Stack<Integer>();
        stack2 = new Stack<Integer>();
    }
    
    public void push(int x) {
        stack1.push(x);
        //若栈中没有元素或此时栈顶元素小于新加入的元素，则新加入元素即为最小元素
        if(stack2.empty() || x <= stack2.peek()){
            stack2.push(x);
        }
    }
    
    public void pop() {
        int tmp = stack1.pop();
        if(tmp == stack2.peek()) stack2.pop();//若弹出元素和辅助栈栈顶元素相同，辅助栈也弹栈
    }
    
    public int top() {
        return stack1.peek();//这个方法可以直接返回栈顶但不删除
    }
    
    public int min() {
        return stack2.peek();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.min();
 */
```





## [剑指 Offer 35. 复杂链表的复制](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/)【中等】

请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。

**示例 1：**

![img](D:/CodeLearning/ComputerScience/MyNote-git/Algorithm/imgs/e1.png) 

```
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
```

**示例 2：**

![img](D:/CodeLearning/ComputerScience/MyNote-git/Algorithm/imgs/e2.png) 

```
输入：head = [[1,1],[2,1]]
输出：[[1,1],[2,1]]
```

**示例 3：**

![img](D:/CodeLearning/ComputerScience/MyNote-git/Algorithm/imgs/e3.png) 

```
输入：head = [[3,null],[3,0],[3,null]]
输出：[[3,null],[3,0],[3,null]]
```

**示例 4：**

```
输入：head = []
输出：[]
解释：给定的链表为空（空指针），因此返回 null。
```

**提示：**

- -10000 <= Node.val <= 10000
- Node.random 为空（null）或指向链表中的节点。
- 节点数目不超过 1000 。

> **未ac**，没看懂题目

**其他思路：**

题目其实就是要实现对一个复杂链表的深拷贝，并不是简单地引用这个链表的同个地址，保证复制出来的新链表每个节点都是新的。

**本题难点：** 在复制链表的过程中构建新链表各节点的 `random` 引用指向。 

**方法一：哈希表**

利用哈希表的查询特点，考虑构建 **原链表节点** 和 **新链表对应节点** 的键值对映射关系，再遍历构建新链表各节点的 `next` 和 `random` 引用指向即可。

**算法流程：**

1. 若头节点 `head` 为空节点，直接返回 `null` ；

2. 初始化： 哈希表 `map` ， 节点 `cur` 指向头节点；

3. 复制链表：
   1. 建立新节点，并向 `map` 添加键值对 `(原 cur 节点, 新 cur 节点)` ；
   2. `cur` 遍历至原链表下一节点；

4. 构建新链表的引用指向：

   1. 构建新节点的 `next` 和 `random` 引用指向；

   2. `cur` 遍历至原链表下一节点；

5. 返回值： 新链表的头节点 `map[cur]` ；

**复杂度分析：**

- 时间复杂度 O(N) ： 两轮遍历链表，使用 O(N) 时间。
- 空间复杂度 O(N) ： 哈希表 map 使用线性大小的额外空间。

```java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/
class Solution {
    public Node copyRandomList(Node head) {//利用哈希表实现复杂链表深拷贝
        if(head == null)    return null;
        Map<Node,Node> map = new HashMap<>();
        Node cur = head;
        //复制各节点，并建立 “原节点 -> 新节点” 的 Map 映射
        while(cur != null){
            map.put(cur,new Node(cur.val));
            cur = cur.next;
        }
        cur = head;
        //构建新链表(难点)
        while(cur != null){
            //注意这里"="右边千万不能写成 cur.next/cur.random，不然还是浅拷贝
            map.get(cur).next = map.get(cur.next);
            map.get(cur).random = map.get(cur.random);
            cur = cur.next;
        }
        return map.get(head);
    }
}
```



**方法二：拼接 + 拆分**

![1633959218384](D:/CodeLearning/ComputerScience/MyNote-git/Algorithm/imgs/1633959218384.png)

```java
class Solution {
    public Node copyRandomList(Node head) {
        if(head == null) return null;
        Node cur = head;
        // 1. 复制各节点，并构建拼接链表
        while(cur != null) {
            Node tmp = new Node(cur.val);
            tmp.next = cur.next;
            cur.next = tmp;
            cur = tmp.next;
        }
        // 2. 构建各新节点的 random 指向
        cur = head;
        while(cur != null) {
            if(cur.random != null)
                cur.next.random = cur.random.next;
            cur = cur.next.next;
        }
        // 3. 拆分两链表
        cur = head.next;
        Node pre = head, res = head.next;
        while(cur.next != null) {
            pre.next = pre.next.next;
            cur.next = cur.next.next;
            pre = pre.next;
            cur = cur.next;
        }
        pre.next = null; // 单独处理原链表尾节点
        return res;      // 返回新链表头节点
    }
}
```





## [剑指 Offer 50. 第一个只出现一次的字符](https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/)【简单】

在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。

**示例 1:**

```
输入：s = "abaccdeff"
输出：'b'
```

**示例 2:**

```
输入：s = "" 
输出：' '
```

**限制：**

- 0 <= s 的长度 <= 50000


**我的思路：**

用哈希表保存字符及其对应出现次数，再遍历查找只出现过一次的字符。（时间空间复杂度都过高）

```java
class Solution {
    public char firstUniqChar(String s) {
        char[] c = s.toCharArray();
        Map<Character,Integer> map = new HashMap<>();//用map保存字符和对应次数
        for(int i = 0;i < s.length();i++){
            if(map.get(c[i]) != null){
                int num = map.get(c[i]);
                num++;
                map.put(c[i],num);
            }else{//避免第一次获取到null值导致空指针异常
                map.put(c[i],1);
            }
        }
        int j;
        for(j = 0;j < s.length();j++){
            if(map.get(c[j]) == 1){//找到出现次数只有一次的字符
                break;
            }
        }
        if(j == s.length()) return ' ';//找不到出现次数只有一次的字符
        return c[j];
    }
}
```

**其他思路：**

使用字典查找

```java
class Solution {	
	public char firstUniqChar(String s) {
        if (s.equals("")) return ' ';
        //创建‘a'-'z'的字典
        int[] target = new int[26];
        //第一次遍历，将字符统计到字典数组
        for (int i = 0; i < s.length(); i++) {
            target[s.charAt(i) - 'a']++;
        }
        //第二次遍历，从字典数组获取次数
        for (int i = 0; i < s.length(); i++) {
            if (target[s.charAt(i) - 'a'] == 1) return s.charAt(i);
        }

        return ' ';//没有只出现一次的字母
    }
}
```

哈希表优化

```java
class Solution {
    public char firstUniqChar(String s) {
        HashMap<Character, Boolean> dic = new HashMap<>();
        char[] sc = s.toCharArray();
        for(char c : sc)
            dic.put(c, !dic.containsKey(c));//当一个字符出现了一次以上，value就会被设定为false
        for(char c : sc)
            if(dic.get(c)) return c;
        return ' ';
    }
}
```

有序哈希表

在哈希表的基础上，有序哈希表中的键值对是 **按照插入顺序排序** 的。基于此，可通过遍历有序哈希表，实现搜索首个 “数量为 1 的字符”。

哈希表是 **去重** 的，即哈希表中键值对数量 ≤ 字符串 s 的长度。因此，相比于普通哈希表，有序哈希表减少了第二轮遍历的循环次数。当字符串很长（重复字符很多）时，有序哈希表则效率更高。

 Java 使用 `LinkedHashMap` 实现有序哈希表。 

```java
class Solution {
    public char firstUniqChar(String s) {
        Map<Character, Boolean> dic = new LinkedHashMap<>();
        char[] sc = s.toCharArray();
        for(char c : sc)
            dic.put(c, !dic.containsKey(c));
        for(Map.Entry<Character, Boolean> d : dic.entrySet()){
           if(d.getValue()) return d.getKey();
        }
        return ' ';
    }
}
```





## [剑指 Offer 53 - I. 在排序数组中查找数字 I](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)【简单】

统计一个数字在排序数组中出现的次数。

**示例 1:**

```
输入: nums = [5,7,7,8,8,10], target = 8
输出: 2
```

**示例 2:**

```
输入: nums = [5,7,7,8,8,10], target = 6
输出: 0
```

**提示：**

- 0 <= nums.length <= 10^5
- -109^9<= nums[i] <= 10^9
- nums 是一个非递减数组
- -10^9 <= target <= 10^9

**我的思路：**

暴力解法，没有用到排序数组这一性质

```java
class Solution {
    public int search(int[] nums, int target) {
        int num = 0;
        for(int i = 0;i < nums.length;i++){
            if(target == nums[i]){
                num++;
            }
        }
        return num;
    }
}
```

使用二分查找找出target在有序数组中的位置，然后前后遍历数组找这个数字出现的次数

```java
class Solution {
    public int search(int[] nums, int target) {

        int num = 0;//记录数字出现的次数
        int i = binarySearch(target,nums,0,nums.length-1);
        if(i == -1) return 0;//不存在该数字，返回0
        int j = i;
        while(j >= 0 && nums[j] == target){
            num++;
            j--;//向左遍历
        }
        i++;//i位置上的已经加上了
        while(i <= nums.length-1 && nums[i] == target){
            num++;
            i++;//向右遍历
        }
        return num;
    }

    //二分法查找target在数组的位置
    int binarySearch(int target, int[] nums, int lo, int hi){
        while(lo <= hi){
            int mid = lo + (hi - lo)/2;
            if(target < nums[mid]) hi = mid - 1;
            else if(target > nums[mid]) lo = mid + 1;
            else return mid;
        }
        return -1;
    }
}
```

优化一下：

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0,right = nums.length - 1;
        int count = 0;
        while(left < right){
            int mid = (left + right) / 2;
            if(nums[mid] >= target)
                right = mid;
            if(nums[mid] < target)
                left = mid + 1;
        }
        while(left < nums.length && nums[left++] == target)
            count++;
        return count;
    }
}
```





## [剑指 Offer 53 - II. 0～n-1中缺失的数字](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/)【简单】

一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。

**示例 1:**

```
输入: [0,1,3]
输出: 2
```

**示例 2:**

```
输入: [0,1,2,3,4,5,6,7,9]
输出: 8
```

**限制：**

- 1 <= 数组长度 <= 10000

**我的思路：**

暴力迭代法（略）

使用二分法查找缺失的数字所在区间位置

```java
class Solution {
    public int missingNumber(int[] nums) {
        int lo = 0, hi = nums.length - 1;
        int mid = 0;
        while(lo <= hi){
            mid = lo + (hi - lo)/2;
            if(nums[mid] == mid) lo = mid + 1;//缺失数字在后半部分
            else hi = mid - 1;//缺失数字在前半部分
        } 
        return lo;
    }
}          
```







## [剑指 Offer 58 - II. 左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)【简单】

字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。

**示例 1：**

```
输入: s = "abcdefg", k = 2
输出: "cdefgab"
```

**示例 2：**

```
输入: s = "lrloseumgh", k = 6
输出: "umghlrlose"
```

**限制：**

- 1 <= k < s.length <= 10000

**我的思路：**

直接调用java的字符串处理api，分别取两部分子串，再进行拼接。

```java
class Solution {
    public String reverseLeftWords(String s, int n) {
        String s1 = s.substring(0,n); 
        String s2 = s.substring(n);
        return s2.concat(s1);
    }
}
```

**其他思路：**

 为了让本题更有意义，提升一下本题难度：不能申请额外空间，只能在本串上操作。 

具体步骤为：

1. 反转区间为前n的子串
2. 反转区间为n到末尾的子串
3. 反转整个字符串

最后就可以得到左旋n的目的，而不用定义新的字符串，完全在本串上操作。

```java
class Solution {
    public String reverseLeftWords(String s, int n) {
        int len=s.length();
        StringBuilder sb=new StringBuilder(s);
        reverseString(sb,0,n-1);//反转区间为前n的子串
        reverseString(sb,n,len-1);//反转区间为n到末尾的子串
        return sb.reverse().toString();//反转整个字符串
    }
     public void reverseString(StringBuilder sb, int start, int end) {
        while (start < end) {
            char temp = sb.charAt(start);
            sb.setCharAt(start, sb.charAt(end));
            sb.setCharAt(end, temp);
            start++;
            end--;
            }
        }
}
```

 



# **LeetCode 题解**



## **数组**

### [704. 二分查找](https://leetcode-cn.com/problems/binary-search/)【简单】

给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target` ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。

**示例 1:**

```
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```

**示例 2:**

```
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```

**提示：**

- 你可以假设 nums 中的所有元素是不重复的。
- n 将在 [1, 10000]之间。
- nums 的每个元素都将在 [-9999, 9999]之间。



**我的思路：**

再编写一个工具方法供**递归**调用，数组的左右下标为左闭右闭区间 [low,high]，所以在递归调用（high = mid - 1、low = mid + 1）以及条件判断（low <= high）时需要注意怎么取值！

```java
class Solution {
    public int search(int[] nums, int target) {
        int low = 0; //左下标
        int high = nums.length - 1; //右下标
        return search1(low, high, nums, target); //递归二分查找
    }

    int search1(int low, int high, int[] nums, int target) {
        int mid = low + (high - low) / 2; //二分
        if(low <= high) {
            if(nums[mid] == target) return mid; //找到目标值下标
            else if(nums[mid] > target) return search1(low, mid - 1, nums, target);
            else return search1(mid + 1, high, nums, target);
        }
        return -1;
    }
}
```

非递归代码：

```java
class Solution {
    public int search(int[] nums, int target) {
        // 避免当 target 小于nums[0] 或大于nums[nums.length - 1] 时多次循环运算
        if (target < nums[0] || target > nums[nums.length - 1]) {
            return -1;
        }
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + ((right - left) >> 1);
            if (nums[mid] == target)
                return mid;
            else if (nums[mid] < target)
                left = mid + 1;
            else if (nums[mid] > target)
                right = mid - 1;
        }
        return -1;
    }
}
```





### [27. 移除元素](https://leetcode-cn.com/problems/remove-element/)【简单】

给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组**。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

**示例 1：**

```
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
```

**示例 2：**

```
输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3]
解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
```

**提示：**

- 0 <= nums.length <= 100
- 0 <= nums[i] <= 50
- 0 <= val <= 100



**我的思路：**

由于数组与元素的内部地址是连续的，不能采取直接删除的方式，所以可以通过**覆盖**的方法，直接使用**双层循环暴力解题**，时间复杂度为 $O(n^2)$，空间复杂度为 $O(1)$

下图为删除过程（取自代码随想录）：

 ![27.移除元素-暴力解法](./imgs/008eGmZEly1gntrc7x9tjg30du09m1ky.gif) 

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int size = nums.length; //记录每一轮移除后数组的新长度
        for(int i = 0; i < size; i++) {
            if(nums[i] == val){ //当有数组元素与目标值相等，将后续元素全部前移一位
                for(int j = i + 1; j < size; j++) {
                    nums[j - 1] = nums[j]; //后一位元素覆盖前一位
                }
                size--; //数组长度-1
                i--; //关键，因为移除的元素后一位也可能是目标元素，这样保证移位后再判断一次这一下标的新元素是否还是等于目标值
            }
        }
        return size;
    }
}
```



**双指针法（快慢指针法）：**

通过一个快指针和慢指针在一个 for 循环下完成两个 for 循环的工作。时间复杂度 $O(n)$，空间复杂度 $O(1)$。

删除过程如下（取自代码随想录）：

 ![27.移除元素-双指针法](./imgs/008eGmZEly1gntrds6r59g30du09mnpd.gif) 

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int slowIndex;
        int fastIndex = 0; //快慢指针(下标)
        for(slowIndex = 0; fastIndex < nums.length; fastIndex++) {
            if(nums[fastIndex] != val) { //快指针元素不等于目标值，就把快的放到慢的
                nums[slowIndex] = nums[fastIndex];
                slowIndex++;
            }
        }
        return slowIndex;
    }
}
```





### [977. 有序数组的平方](https://leetcode-cn.com/problems/squares-of-a-sorted-array/)【简单】

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

**示例 1：**

```
输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]
```

**示例 2：**

```
输入：nums = [-7,-3,2,3,11]
输出：[4,9,9,49,121]
```

**提示：**

- 1 <= nums.length <= 104
- -104 <= nums[i] <= 104
- nums 已按 非递减顺序 排序

**进阶：**

- 请你设计时间复杂度为 O(n) 的算法解决本问题




**我的思路：**

**暴力解法**，先将原数组每个元素都进行平方，再对得到的数组进行排序（冒泡、选择、插入......），这种情况下复杂度为 $O(n^2)$，就算将排序算法优化为快速排序，平均算法复杂度也至少需要 $O(n + nlogn)$

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        // 先将每个元素取平方
        for(int i = 0;i < nums.length; i++) {
            nums[i] = nums[i] * nums[i];
        }
        // 将数组排序(升序) 这里用插入排序
        for (int i = 1;i < nums.length;i++) {
            //默认第一个元素已被排序好了
            for (int j = i;j > 0;j--) {
                if (nums[j] < nums[j - 1]) {
                    int temp = nums[j];
                    nums[j] = nums[j - 1];
                    nums[j - 1] = temp;
                }
            }
        }
        return nums;
    }
}
```

**进阶：**设计复杂度为 $O(n)$ 的算法，则不能直接将数组平方再使用传统的排序算法来进行排序，在这种情况下，我们可以利用**“空间换时间”**的思想，先定义一个与原数组同样大小的数组，再用**双指针法**依次将平方后的元素填入新数组，具体思路如下：

1. 数组其实是**有序**的，但是有可能负数绝对值更大导致平方之后成为最大的数。
2. 所以可以知道数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。
3. 用**双指针法**，分别用 **left** 指向起始位置（左边），**right** 指向终止位置（右边）。两个指针是不断往中间移动的。
4. 定义一个新数组 result ，和 nums 数组一样的大小，让 **index** 指向 result 数组终止位置，index 不断向前移动，即 result 数组的元素填充实际上是从后到前、从大到小填充的。
   - 如果 `nums[left] * nums[left] < nums[right] * nums[right]` 那么 `result[index--] = nums[right] * nums[right];` 。
   - 如果 `nums[left] * nums[left] >= nums[right] * nums[right]` 那么 `result[index--] = nums[left] * nums[left];` 。

图示如下（取自代码随想录）：

 ![img](https://code-thinking.cdn.bcebos.com/gifs/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif) 

```java
class Solution {
    public int[] sortedSquares(int[] nums) { //注意输入数组是有序的
    	int left = 0; //输入数组的左指针
        int right = nums.length - 1; //输入数组的右指针
        int[] result = new int[nums.length]; //存放结果集
        int index = result.length - 1; //结果集定位指针
        while(left <= right) {
            //当输入数组左侧(可能是负数也可能不是)平方大于右侧平方
            if(nums[left] * nums[left] > nums[right] * nums[right]) {
				result[index--] = nums[left] * nums[left];
                left++;
            } else { //否则
                result[index--] = nums[right] * nums[right];
                right--;
            }
        }
        return result;
    }
}
```





### [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)【中等】

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其和 `≥ target` 的长度最小的 **连续子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。

**示例 1：**

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

**示例 2：**

```
输入：target = 4, nums = [1,4,4]
输出：1
```

**示例 3：**

```
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
```

**提示：**

- 1 <= target <= 109
- 1 <= nums.length <= 105
- 1 <= nums[i] <= 105

**进阶：**

- 如果你已经实现 `O(n)` 时间复杂度的解法, 请尝试设计一个 `O(n log(n))` 时间复杂度的解法。



**我的思路：**

苦思冥想十分钟，只想到一中双层 for 循环的暴力解法，时间复杂度为 $O(n^2)$，具体思路如下：

1. 外层循环不断往后迭代下标，即每轮的子数组的首个元素是上一轮的子数组首元素的下一位元素。
2. 进入内层循环，从子数组的首元素开始往后叠加 sum，直到满足 `sum >= target`。
3. 满足上面的条件后，接着进行下一个判断：判断当前子数组中已经叠加的部分序列的长度（`j - i + 1`）是否小于之前那么多轮外层循环下记录的“当前”子数组最小长度，若小于，则将当前子序列长度记录在 min，跳出内层循环，继续开始下一个子数组的迭代判断。若大于，直接跳出内层循环，继续开始下一个子数组的迭代判断。
4. 最后需要判断当前记录的 min 是否小于 `nums.length + 1`，若小于，则证明确实存在满足条件的子数组，输出这个 min 即可~

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int sum; //记录子数组的和
        int min = nums.length + 1; //记录满足条件的当前最小的子数组长度，这里+1是为了方便最后判断是否不存在满足条件的子数组
        for(int i = 0; i < nums.length; i++) {
            sum = 0;
            for(int j = i; j < nums.length; j++) {
                sum += nums[j];
                if(sum >= target) { //找出满足"和>=target"的子序列
                    if((j - i + 1) < min) { //如果该子序列长度小于min
                        min = j - i + 1; //取当前子序列长度为满足条件的最小子数组长度
                        break; //跳出内层循环，往后取下一个子序列
                    }
                    break; //跳出内层循环，往后取下一个子序列
                }
            }
        }
        return min < nums.length + 1 ? min : 0;
    }
}
```

**进阶**：（参考自代码随想录）

**滑动窗口（实质上就是双指针法）**。所谓滑动窗口，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。

这里还是以题目中的示例来举例，target=7， 数组是 2，3，1，2，4，3，来看一下查找的过程：

 ![209.长度最小的子数组](https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif) 

最后找到 4，3 是最短距离。

其实从动画中可以发现滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。

在本题中实现滑动窗口，主要确定如下三点：

- 窗口内是什么？
- 如何移动窗口的起始位置？
- 如何移动窗口的结束位置？

窗口就是 **满足其和 ≥ target 的长度最小的 连续 子数组**。

窗口的起始位置如何移动：如果当前窗口的值大于了 target，窗口就要向前移动了（也就是该缩小了）。

窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，窗口的起始位置设置为数组的起始位置就可以了。

解题的关键在于 窗口的起始位置如何移动，如图所示：

 ![leetcode_209](./imgs/20210312160441942.png) 

可以发现**滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将$O(n^2)$的暴力解法降为$O(n)$。** 

```java
class Solution {
    // 滑动窗口
    public int minSubArrayLen(int target, int[] nums) {
        int left = 0; //窗口起始位置
        int sum = 0;
        int result = Integer.MAX_VALUE; //存放当前满足条件的最小子数组长度
        for (int right = 0; right < nums.length; right++) {
            sum += nums[right];
            while (sum >= target) {
                result = Math.min(result, right - left + 1);
                sum -= nums[left++]; //当窗口内子数组和满足条件，就挤出最左边的一个元素
            }
        }
        return result == Integer.MAX_VALUE ? 0 : result;
    }
}
```





### [59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/)【中等】

给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。

 **示例 1：** 

 ![img](./imgs/spiraln.jpg) 

```
输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]
```

**示例 2：**

```
输入：n = 1
输出：[[1]]
```

**提示：**

- `1 <= n <= 20`



**思路：**

这道题目其实并没有涉及什么复杂的算法，难的是模拟这个螺旋的过程以及代码的细节，具体的思路偷个懒，直接贴上卡哥的代码随想录啦~

求解本题是要坚持循环不变量原则。

模拟顺时针画矩阵的过程:

- 填充上行从左到右
- 填充右列从上到下
- 填充下行从右到左
- 填充左列从下到上

由外向内一圈一圈这么画下去。

这里一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开又闭的原则，这样这一圈才能按照统一的规则画下来。

那么按照左闭右开的原则，来画一圈，如下：

 ![螺旋矩阵](./imgs/2020121623550681.png) 

这里每一种颜色，代表一条边，我们遍历的长度，可以看出每一个拐角处的处理规则，拐角处让给新的一条边来继续画。这也是坚持了每条边左闭右开的原则。

```java
class Solution {
    public int[][] generateMatrix(int n) {
        int[][] res = new int[n][n];
        int loop = n / 2; // 循环次数(n=4的矩阵里外共2层(4/2),n=5的矩阵里外2层+1个中央元素)
        // 定义每次循环起始位置
        int startX = 0; // 横
        int startY = 0; // 纵
        int offset = 1; // 偏移量(随着螺旋进入内层会增加)
        int count = 1; // 填充数字
        // 定义中间位置(n为奇数矩阵才有中间位置)
        int mid = n / 2;
        while (loop > 0) {
            int i = startX;
            int j = startY;
            // 模拟上侧从左到右
            for (; j<startY + n -offset; ++j) {
                res[startX][j] = count++;
            }
            // 模拟右侧从上到下
            for (; i<startX + n -offset; ++i) {
                res[i][j] = count++;
            }
            // 模拟下侧从右到左
            for (; j > startY; j--) {
                res[i][j] = count++;
            }
            // 模拟左侧从下到上
            for (; i > startX; i--) {
                res[i][j] = count++;
            }

            loop--;
            startX += 1;
            startY += 1;
            offset += 2;
        }
        // 如果n为奇数，最后正中间位置的数字直接填充count
        if (n % 2 == 1) {
            res[mid][mid] = count;
        }
        return res;
    }
}
```







## **链表**

### [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)【简单】

给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。

**示例 1：**

 <img src="./imgs/removelinked-list.jpg" alt="img" style="zoom:67%;" /> 

```
输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]
```

**示例 2：**

```
输入：head = [], val = 1
输出：[]
```

**示例 3：**

```
输入：head = [7,7,7,7], val = 7
输出：[]
```

**提示：**

- 列表中的节点数目在范围 [0, 104] 内
- 1 <= Node.val <= 50
- 0 <= val <= 50



**思路：**

对于头节点需要单独的代码来处理，先将不为空且值为 val 的节点移除掉，这样就能拿到一个头节点绝对不为空且值不等于 val 的单链表，接下来就对头节点后的节点进行循环判断，需要两个指针，一个指向当前判断节点的前驱节点（pre），另一个指向当前节点（cur），这样主要是为了方便删除值等于 val 的当前节点。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        while(head != null && head.val == val) { //若头节点不为空且值为val
            head = head.next;
        }
        if(head == null)    return head; //如果已经为null了，链表到头了直接返回
        
        //运行到此处，目前head所指元素非空且值不等于val
        ListNode pre = head; //前驱节点
        ListNode cur = head.next; //当前节点
        while(cur != null) {
            if(cur.val == val){
                pre.next = cur.next; //当前节点cur值为val，则删除cur节点
            } else {
                pre = cur; //前驱节点后移至当前节点位置
            }
            cur = cur.next;
        }
        return head;
    }
}
```

**另外的解法：**

以一种统一的逻辑来移除链表的节点，其实**可以设置一个虚拟头结点**，这样原链表的所有节点就都可以按照统一的方式进行移除了。

来看看如何设置一个虚拟头。依然还是在这个链表中，移除元素1。

 ![203_链表删除元素6](./imgs/20210316095619221.png) 

这里来给链表添加一个虚拟头结点为新的头结点，此时要移除这个旧头结点元素1。

这样就可以使用统一的逻辑移除链表所有符合条件的节点，最后 return 头结点的时候，别忘了 `return dummyNode.next;`， 这才是新的头结点。

```java
/**
 * 添加虚节点方式
 * 时间复杂度 O(n)
 * 空间复杂度 O(1)
 * @param head
 * @param val
 * @return
 */
public ListNode removeElements(ListNode head, int val) {
    if (head == null) {
        return head;
    }
    // 因为删除可能涉及到头节点，所以设置dummy节点，统一操作
    ListNode dummy = new ListNode(-1, head);
    ListNode pre = dummy;
    ListNode cur = head;
    while (cur != null) {
        if (cur.val == val) {
            pre.next = cur.next;
        } else {
            pre = cur;
        }
        cur = cur.next;
    }
    return dummy.next;
}
```