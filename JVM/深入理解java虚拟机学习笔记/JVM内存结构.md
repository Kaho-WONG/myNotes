# Java 内存区域

[toc]



# 运行时数据区域

Java 虚拟机内存空间包括以下几个运行时数据区域：

<img src="./imgs/1639121224688.png" alt="1639121224688" style="zoom:50%;" />

- 程序计数器（Program Counter Register）
- Java 虚拟机栈（Java Virtual Machine Stack）
- 本地方法栈（Native Method Stack）
- 堆（Heap）
- 方法区（Method Area）



## 1. 程序计数器

### 1.1 定义

程序计数器是一块较小的内存空间，它可以看作是**当前线程所执行的字节码的行号指示器**。 **字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成**。

若当前线程正在执行的是一个 **Java 方法**，则计数器记录的是**正在执行的那条虚拟机字节码指令的地址**；若当前线程正在执行的是一个**本地（Native）方法**，那么此时程序计数器值为**空（Undefined）**。 

### 1.2 作用

- 字节码解释器通过改变程序计数器的值来依次读取字节码指令，从而实现代码的流程控制。
- 在多线程环境下，程序计数器记录当前线程执行的位置，从而当线程切换后能够恢复到正确的执行位置。

### 1.3 特点

- 一块较小的内存空间。
- **线程私有**，每条线程都有自己独立的程序计数器。
- 唯一一个不会出现 `OutOfMemoryError` 的内存区域。
- 随线程的创建而创建，随线程的结束而销毁。



## 2. Java 虚拟机栈

### 2.1 定义

Java 虚拟机栈描述的是 **Java 方法执行的线程内存模型**：Java 虚拟机栈会为每一个即将执行的 Java 方法创建一块叫做`栈帧`的区域，用于存放该方法运行过程中的一些信息，如：

- 局部变量表
- 操作数栈
- 动态链接
- 方法出口信息
- ......

<img src="./imgs/jvm-stack.jpg" alt="jvm-stack" style="zoom: 67%;" /> 

**每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。**

### 2.2 特点

- 运行速度特别快，仅次于程序计数器。

- Java 虚拟机栈也是**线程私有**，随线程创建而创建，随线程的结束而销毁。

- 局部变量表随着栈帧的创建而创建，它的大小在编译时确定。在方法运行过程中，局部变量表的大小不会发生改变。

- Java 虚拟机栈会出现两种异常：`StackOverFlowError` 和 `OutOfMemoryError`。

  - 若 Java 虚拟机栈的内存大小不允许动态扩展，当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度时，抛出 `StackOverFlowError` 异常。（出现 `StackOverFlowError` 时，内存空间可能还有很多。）
- 若 Java 虚拟机栈容量允许动态扩展，那么当栈扩展时无法申请到足够的内存时，抛出 `OutOfMemoryError` 异常。
  
  ![1640421581558](./imgs/1640421581558.png)

### 2.3 局部变量表

一个数字数组，主要用于**存储方法参数和定义在方法体内部的局部变量**，包括各类**基本数据类型**（`boolean`、`byte`、`char`、`short`、`int`、`float`、`long`、`double`）、**对象引用**（reference 类型）、以及 **return address 类型**（指向了一条字节码指令的地址）。 

最基本的存储单元是**局部变量槽 `slot`**。64 位的 long 和 double 类型占用两个 slot，其余数据类型只占用一个。**局部变量表容量大小（槽数量）是在编译期确定下来的**。

>对于 slot 的理解：
>
>- JVM 会为局部变量表中的每个 slot 都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值。
>- 如果当前帧是由构造方法或者实例方法创建的，那么该对象引用 `this`，会存放在 index 为 0 的 slot 处，其余的参数表顺序继续排列。
>- 栈帧中的局部变量表中的槽位是可以重复的，如果一个局部变量过了其作用域，那么其作用域之后申明的新的局部变量就有可能会复用过期局部变量的槽位，从而达到节省资源的目的。

在栈帧中，与性能调优关系最密切的部分，就是局部变量表。方法执行时，虚拟机使用局部变量表完成方法的传递；局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。

**扩展：方法/函数如何调用？**

Java 栈可以类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。

Java 方法有两种返回方式：

1. return 语句。
2. 抛出异常。

不管哪种返回方式都会导致栈帧被弹出。



## 3. 本地方法栈

### 3.1 定义

本地方法栈是为 JVM **运行 Native 方法**准备的空间，由于很多 Native 方法都是用 C 语言实现的，所以它通常又叫 C 栈。它与 Java 虚拟机栈实现的功能类似，只不过本地方法栈是描述**本地方法运行过程的内存模型**。 

### 3.2 栈帧变化过程

本地方法被执行时，在本地方法栈也会创建一块栈帧，用于存放该方法的局部变量表、操作数栈、动态链接、方法出口信息等。

方法执行结束后，相应的栈帧也会出栈，并释放内存空间。在栈深度溢出或者栈扩展失败时也会抛出 `StackOverFlowError` 和 `OutOfMemoryError` 异常。

>如果 Java 虚拟机本身不支持 Native 方法，或是本身不依赖于传统栈，那么可以不提供本地方法栈。如果支持本地方法栈，那么这个栈一般会在线程创建的时候按线程分配。



## 4. Java 堆

### 4.1 定义

堆是虚拟机所管理的内存中**最大**的一块，是**用来存放对象实例**的内存空间，**`几乎`所有的对象实例都在这里分配内存**。

> Java 世界中“几乎”所有的对象都在堆中分配，但是，随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。

### 4.2 特点

- 线程共享，整个 Java 虚拟机只有一个堆，所有的线程都访问同一个堆；而程序计数器、Java 虚拟机栈、本地方法栈都是一个线程对应一个。
- 在虚拟机启动时创建。
- 是垃圾收集器管理的内存区域，是垃圾回收的主要场所。
- 《Java 虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。
- 既可以被实现成固定大小的，也可以是可扩展的（当前主流）。
- 如果堆中没有内存完成实例分配，并且堆也无法再扩展时，会抛出 `OutOfMemoryError` 异常，主要表现形式如以下几种：
  1. **`java.lang.OutOfMemoryError: GC Overhead Limit Exceeded`**：当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。
  2.  **`java.lang.OutOfMemoryError: Java heap space`**：假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。（和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过`-Xmx`参数配置，若没有特别配置，将会使用默认值。）
  3. ......

### 4.3 新生代与老年代

Java 堆是垃圾收集器管理的主要区域，也被称作**GC 堆（Garbage Collected Heap）**。从垃圾回收的角度，由于现在收集器基本都采用**分代垃圾收集算法**，所以 Java 堆还可以细分为：`新生代`和`老年代`；再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。**这样划分的目的是更好地回收内存，或者更快地分配内存**。

在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：

1. 新生代内存(Young Generation)
2. 老生代(Old Generation)
3. 永生代(Permanent Generation)

<img src="./imgs/1640422205820.png" alt="1640422205820" style="zoom:67%;" />

JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是**元空间**，元空间使用的是**直接内存**。 

<img src="./imgs/1640422277782.png" alt="1640422277782" style="zoom:67%;" />

**上图所示的 Eden 区、两个 Survivor 区都属于新生代（为了区分，这两个 Survivor 区域按照顺序被命名为 from 和 to），中间一层属于老年代。**

大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1（Eden 区->Survivor 区后对象的初始年龄变为 1），当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。



## 5. 方法区

### 5.1 定义

《Java 虚拟机规范》中定义方法区是**堆的一个逻辑部分**，是各个线程共享的内存区域 。用于存储以下信息：

- 已经被虚拟机加载的类信息
- 常量
- 静态变量
- 即时编译器编译后的代码缓存
- ......

### 5.2 特点

- **线程共享**。方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。整个虚拟机中只有一个方法区。
- 永久代。方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，把方法区称为“永久代”。
- 内存回收效率低。方法区中的信息一般需要长期存在，回收一遍之后可能只有少量信息无效。主要回收目标是：针对常量池的回收和对类型的卸载。
- 《Java 虚拟机规范》对方法区的要求比较宽松。和堆一样，允许固定大小，也允许动态扩展，还允许不实现垃圾回收。



### 5.3 运行时常量池

方法区的一部分，方法区中存储的**常量**就存放在运行时常量池中。

当类被 JVM 加载后，`.class` 文件中的常量池表用于存放编译期生成的各种字面量和符号引用，这部分内容会存放到方法区的运行时常量池中。在运行期间，可以向常量池中加入新的常量（如 String 类的 `intern()` 方法）。

当常量池无法申请到内存时会抛出 `OutOfMemoryError` 异常。

***



## 6. 直接内存（堆外内存）

直接内存**并非虚拟机运行时数据区的一部分**，也不是《Java 虚拟机规范》中定义的内存区域，但这部分内存也被 Java 频繁使用。

### 6.1 作用

在 JDK 1.4 中新加入的 NIO 类引入了一种基于**通道**和**缓冲**的 I/O 方式。它可以通过调用 Native 函数库直接分配堆外内存，然后通过一个存储在堆中的 `DirectByteBuffer` 对象操作该内存，而无须先将堆外内存中的数据复制到堆中再进行操作，从而提高了数据操作的效率。

直接内存的大小不受 Java 虚拟机控制，但会受到本机总内存大小以及处理器寻址空间的限制，当内存不足动态扩展时就会抛出 `OutOfMemoryError` 异常。

> 服务器管理员在配置虚拟机参数时，会根据实际内存设置 `-Xmx` 等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现 `OutOfMemoryError` 异常。 

### 6.2 堆内存 VS 直接内存

- 直接内存申请空间耗费更大。
- 直接内存读取 IO 的性能要优于普通的堆内存。
- 直接内存作用链： 本地 IO — 直接内存 — 本地 IO
- 堆内存作用链：本地 IO — 直接内存 — 非直接内存 — 直接内存 — 本地 IO





# HotSpot 虚拟机对象探秘



## 1. 对象的内存布局

在 HotSpot 虚拟机里，对象在堆内存中的存储布局分为三个部分：

- 对象头（Header）
- 实例数据（Instance Data）
- 对齐填充（Padding）

![object-memory-layout.png](./imgs/object-memory-layout.png) 

**Hotspot 虚拟机的对象头包括两部分信息**，**第一部分用于存储对象自身的运行时数据**（哈希码、GC 分代年龄、锁状态标志等等），**另一部分是类型指针**，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。

**实例数据部分是对象真正存储的有效信息**，也是在程序中所定义的各种类型的字段内容。

**对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。** 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。



## 2. 对象的创建

 ![img](./imgs/592743-20160319235423381-1926278401.png) 

### 2.1 类加载检查

虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

### 2.2 分配内存

在**类加载检查**通过后，接下来虚拟机将为新生对象**分配内存**。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。**分配方式**有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定**。

**内存分配的两种方式：** 

选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的。

|          |              适用场合              |                             原理                             |    GC收集器    |
| :------: | :--------------------------------: | :----------------------------------------------------------: | :------------: |
| 指针碰撞 | 堆内存规整的情况下（没有内存碎片） | 用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界值指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可 | Serial、ParNew |
| 空闲列表 |        堆内存不规整的情况下        | 虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块来划分给对象实例，最后更新列表记录 |      CMS       |

**内存分配并发问题：**

在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：

- **CAS+失败重试**： CAS 是**乐观锁**的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
- **TLAB**： 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配。

### 2.3 初始化零值

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

### 2.4 设置对象头

初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中。** 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

### 2.5 执行 init 方法

在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，`<init>` 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 `<init>` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。



## 3. 对象的访问定位

建立对象就是为了使用对象，Java 程序通过栈上的 **reference 数据**来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有**`使用句柄`**和**`直接指针`**两种：

1. **句柄**：如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；

![1640431862715](./imgs/1640431862715.png)

2. **直接指针**：如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。

![1640431934201](./imgs/1640431934201.png)

> 使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。











