# JVM 垃圾回收

[toc]



**当需要排查各种内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。** 

为了更好地理解 JVM 的垃圾回收，需要注意解决下面的问题：

- 内存是如何分配和回收的？
- 哪些垃圾需要回收？
- 什么时候进行回收？
- 如何回收？



## 1. JVM 内存分配和回收的原理解析

Java 的自动内存管理主要是针对**对象内存的分配**和**对象内存的回收**。更确切的说，Java 自动内存管理的核心是 **堆** 内存中对象的分配与回收。 

Java 堆是垃圾收集器管理的主要区域，也被称作**GC 堆（Garbage Collected Heap）**。从垃圾回收的角度，由于现在收集器基本都采用**分代垃圾收集算法**，所以 Java 堆还可以细分为：`新生代`和`老年代`；再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。**这样划分的目的是更好地回收内存，或者更快地分配内存。** 

**下图是堆空间的基本结构：** 

![1640872809887](D:\CodeLearning\ComputerScience\MyNote-git\JVM\深入理解java虚拟机学习笔记\imgs\1640872809887.png)

> 上图所示的 `Eden` 区、`From Survivor0`("From") 区、`To Survivor1`("To") 区都属于新生代，`Old Memory` 区属于老年代。 

大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为大于 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置默认值，这个值会在虚拟机运行过程中进行调整，可以通过 `-XX:+PrintTenuringDistribution` 来打印出当次 GC 后的 Threshold。

> “Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。 

经过这次 GC 后，Eden 区和"From"区已经被清空。这个时候，"From"和"To"会交换他们的角色，也就是新的"To"就是上次 GC 前的“From”，新的"From"就是上次 GC 前的"To"。不管怎样，都会保证名为 To 的 Survivor 区域是空的。Minor GC 会一直重复这样的过程，在这个过程中，有可能当次Minor GC后，Survivor 的"From"区域空间不够用，有一些还达不到进入老年代条件的实例放不下，则放不下的部分会提前进入老年代。



### 1.1 堆内存分配策略

- 对象优先在 eden 区分配
- 大对象直接进入老年代
- 长期存活的对象将进入老年代



#### 1.1.1 对象优先在 eden 区分配

目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代，这样就可以根据各个年代的特点选择合适的垃圾收集算法。

大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。



