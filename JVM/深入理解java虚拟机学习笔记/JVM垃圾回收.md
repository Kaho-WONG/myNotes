# JVM 垃圾回收

[toc]



**当需要排查各种内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。** 

为了更好地理解 JVM 的垃圾回收，需要注意解决下面的问题：

- 内存是如何分配和回收的？
- 哪些垃圾需要回收？
- 什么时候进行回收？
- 如何回收？



## 1. JVM 内存分配和回收的原理解析

Java 的自动内存管理主要是针对**对象内存的分配**和**对象内存的回收**。更确切的说，Java 自动内存管理的核心是 **堆** 内存中对象的分配与回收。 

Java 堆是垃圾收集器管理的主要区域，也被称作**GC 堆（Garbage Collected Heap）**。从垃圾回收的角度，由于现在收集器基本都采用**分代垃圾收集算法**，所以 Java 堆还可以细分为：`新生代`和`老年代`；再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。**这样划分的目的是更好地回收内存，或者更快地分配内存。** 

**下图是堆空间的基本结构：** 

![1640872809887](D:\CodeLearning\ComputerScience\MyNote-git\JVM\深入理解java虚拟机学习笔记\imgs\1640872809887.png)

> 上图所示的 `Eden` 区、`From Survivor0`("From") 区、`To Survivor1`("To") 区都属于新生代，`Old Memory` 区属于老年代。 

大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为大于 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置默认值，这个值会在虚拟机运行过程中进行调整，可以通过 `-XX:+PrintTenuringDistribution` 来打印出当次 GC 后的 Threshold。

> “Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。 

经过这次 GC 后，Eden 区和"From"区已经被清空。这个时候，"From"和"To"会交换他们的角色，也就是新的"To"就是上次 GC 前的“From”，新的"From"就是上次 GC 前的"To"。不管怎样，都会保证名为 To 的 Survivor 区域是空的。Minor GC 会一直重复这样的过程，在这个过程中，有可能当次Minor GC后，Survivor 的"From"区域空间不够用，有一些还达不到进入老年代条件的实例放不下，则放不下的部分会提前进入老年代。



### 针对 GC 的统一定义

- **部分收集（Partial GC）**：指目标不是完整收集整个 Java 堆的垃圾收集，可分为：
  - **新生代收集（Minor GC / Young GC）**：只对**新生代**进行垃圾收集；
  - **老年代收集（Major GC / Old GC）**：只对**老年代**进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；
  - **混合收集（Mixed GC）**：对**整个新生代和部分老年代**进行垃圾收集。
-  **整堆收集（Full GC）**：收集**整个 Java 堆和方法区**。 



### 1.1 堆内存分配与回收策略

Java 技术体系的自动内存管理，最根本的目标是自动化地解决两个问题：**自动给对象分配内存** 和 **自动会少分配给对象的内存**。

对象的内存分配，从概念上讲，应该都是在**堆**上分配（而实际上也有可能经过即时编译后被拆散为标量类型并间接地在栈上分配）。在经典分代的设计下，**新生对象通常会分配在新生代中，少数情况下（例如对象大小超过一定阈值）也可能直接分配在老年代。**

常见内存分配原则如下：

- **对象优先在 eden 区分配**
- **大对象直接进入老年代**
- **长期存活的对象将进入老年代**



#### 1.1.1 对象优先在 eden 区分配

大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。









